This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-06-15T20:36:51.369Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Info

For more information about Repomix, visit: https://github.com/yamadashy/repomix

# Repository Structure
```
.github/
  workflows/
    release_package.yml
src/
  admin/
    lib/
      sdk.ts
    routes/
      attributes/
        page.tsx
    widgets/
      category-attributes.tsx
      product-attributes.tsx
    README.md
    tsconfig.json
    vite-env.d.ts
  api/
    admin/
      plugin/
        attribute-set/
          [id]/
            middlewares.ts
          middlewares.ts
          query-config.ts
          route.ts
          validators.ts
        attributes/
          [id]/
            values/
              [valueId]/
                middlewares.ts
                route.ts
              route.ts
            route.ts
          bulk-delete/
            route.ts
          middlewares.ts
          query-config.ts
          route.ts
          validators.ts
        route.ts
      products/
        [id]/
          attributes/
            [valueId]/
              route.ts
            middlewares.ts
            route.ts
        middlewares.ts
      middlewares.ts
    store/
      plugin/
        attributes/
          filters/
            middlewares.ts
          products/
            [id]/
              middlewares.ts
            middlewares.ts
            query-config.ts
            route.ts
            validators.ts
          middlewares.ts
          query-config.ts
          route.ts
          validators.ts
        route.ts
      middlewares.ts
    utils/
      common-validators.ts
      constants.ts
      middlewares.ts
    middlewares.ts
  jobs/
    README.md
  links/
    attribute-product-category.ts
    attribute-value-product.ts
    README.md
  modules/
    attribute/
      events/
        index.ts
      models/
        attribute-possible-value.ts
        attribute-set.ts
        attribute-value.ts
        attribute.ts
      types/
        attribute/
          common.ts
          index.ts
        attribute-set/
          index.ts
          mutations.ts
        attribute-value/
          index.ts
          mutations.ts
        index.ts
      index.ts
      service.ts
    README.md
  providers/
    README.md
  subscribers/
    README.md
  types/
    attribute/
      http/
        attribute/
          index.ts
        index.ts
      common.ts
      index.ts
  utils/
    index.ts
    products-created-handler.ts
    products-updated-handler.ts
    validate-attribute-values-to-link.ts
  workflows/
    attribute/
      steps/
        create-attribute-possible-values.ts
        create-attributes.ts
        delete-attribute.ts
        index.ts
        update-attributes.ts
      workflows/
        create-attribute-possible-values.ts
        create-attributes.ts
        delete-attribute.ts
        index.ts
        update-attributes.ts
      index.ts
    attribute-set/
      steps/
        create-attribute-set.ts
        index.ts
      workflows/
        create-attribute-set.ts
    attribute-value/
      steps/
        create-attribute-value.ts
        delete-attribute-value.ts
        index.ts
        validate-attribute-value.ts
      workflow/
        create-attribute-value.ts
        delete-attribute-value.ts
        index.ts
    index.ts
    README.md
.gitignore
package.json
repomix.config.json
tsconfig.json
```

# Repository Files

## File: .github/workflows/release_package.yml
```yaml
name: Release package
on:
  workflow_dispatch:
    inputs:
      release-type:
        description: 'Release type (one of): patch, minor, major, prepatch, preminor, premajor, prerelease'
        required: true
jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      # Checkout project repository
      - name: Checkout
        uses: actions/checkout@v2.3.4

      # Setup Node.js environment
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          registry-url: https://registry.npmjs.org/
          node-version: '20'

      # Install dependencies (required by publish step, since medusa cli is used)
      - name: Install dependencies
        run: yarn install

      # Tests
      #- name: Run tests
      #  run: yarn test

      # Configure Git
      - name: Git configuration
        run: |
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --global user.name "GitHub Actions"

      # Bump package version
      # Use tag latest
      - name: Bump release version
        if: startsWith(github.event.inputs.release-type, 'pre') != true
        run: |
          echo "NEW_VERSION=$(npm --no-git-tag-version version $RELEASE_TYPE)" >> $GITHUB_ENV
          echo "RELEASE_TAG=latest" >> $GITHUB_ENV
        env:
          RELEASE_TYPE: ${{ github.event.inputs.release-type }}

      # Bump package pre-release version
      # Use tag beta for pre-release versions
      - name: Bump pre-release version
        if: startsWith(github.event.inputs.release-type, 'pre')
        run: |
          echo "NEW_VERSION=$(npm --no-git-tag-version --preid=beta version $RELEASE_TYPE
          echo "RELEASE_TAG=beta" >> $GITHUB_ENV
        env:
          RELEASE_TYPE: ${{ github.event.inputs.release-type }}

      # Update changelog unreleased section with new version
      - name: Update changelog
        uses: superfaceai/release-changelog-action@v1
        with:
          path-to-changelog: CHANGELOG.md
          version: ${{ env.NEW_VERSION }}
          operation: release

      # Commit changes
      - name: Commit CHANGELOG.md and package.json changes and create tag
        run: |
          git add "package.json"
          git add "CHANGELOG.md"
          git commit -m "chore: release ${{ env.NEW_VERSION }}"
          git tag ${{ env.NEW_VERSION }}

      # Build Medusa
      - name: Build
        run: npx medusa plugin:build

      # Publish version to public repository
      - name: Publish
        run: yarn publish --verbose --access public --tag ${{ env.RELEASE_TAG }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPMJS_ACCESS_TOKEN }}

      # Push repository changes
      - name: Push changes to repository
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git push origin && git push --tags

      # Read version changelog
      - id: get-changelog
        name: Get version changelog
        uses: superfaceai/release-changelog-action@v1
        with:
          path-to-changelog: CHANGELOG.md
          version: ${{ env.NEW_VERSION }}
          operation: read

      # Update GitHub release with changelog
      - name: Update GitHub release documentation
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.NEW_VERSION }}
          body: ${{ steps.get-changelog.outputs.changelog }}
          prerelease: ${{ startsWith(github.event.inputs.release-type, 'pre') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

## File: src/admin/lib/sdk.ts
```typescript
import Medusa from "@medusajs/js-sdk"

// For plugins, use the global __BACKEND_URL__ variable
// For Medusa projects, use import.meta.env.VITE_MEDUSA_BACKEND_URL
export const sdk = new Medusa({
  baseUrl: __BACKEND_URL__, // This is automatically available in plugins
  debug: process.env.NODE_ENV === "development",
  auth: {
    type: "session" // Uses cookie session authentication
  }
})
```

## File: src/admin/routes/attributes/page.tsx
```typescript
import { defineRouteConfig } from "@medusajs/admin-sdk"
import { useState, useEffect } from "react"
import { useQuery, useMutation } from "@tanstack/react-query"
import {
  Container,
  Heading,
  Button,
  Table,
  Badge,
  IconButton,
  Drawer,
  Input,
  Label,
  Textarea,
  Switch,
  Text,
  usePrompt,
  Checkbox,
  toast
} from "@medusajs/ui"
import { PencilSquare, Trash, Plus, Tag } from "@medusajs/icons"
import { CategoryCombobox } from "../../components/category-combobox"
import { sdk } from "../../lib/sdk" // Import your configured SDK

interface Attribute {
  id: string
  name: string
  description?: string
  handle: string
  is_variant_defining: boolean
  is_filterable: boolean
  possible_values?: Array<{
    id: string
    value: string
    rank: number
  }>
  product_categories?: Array<{
    id: string
    name: string
  }>
  created_at: string
  updated_at: string
}

interface Category {
  id: string
  name: string
  handle: string
  category_children?: Category[]
}

const AttributesPage = () => {
  const [selectedRows, setSelectedRows] = useState<Set<string>>(new Set())
  const [isDrawerOpen, setIsDrawerOpen] = useState(false)
  const [editingAttribute, setEditingAttribute] = useState<Attribute | null>(null)

  const prompt = usePrompt()

  // Form state
  const [formData, setFormData] = useState({
    name: '',
    description: '',
    handle: '',
    is_filterable: true,
    possible_values: [{ value: '', rank: 1 }],
    product_category_ids: [] as string[]
  })

  // Query for attributes using TanStack Query + SDK
  const {
    data: attributesData,
    isLoading: attributesLoading,
    refetch: refetchAttributes
  } = useQuery({
    queryKey: ["admin-attributes"],
    queryFn: async () => {
      return await sdk.client.fetch(`/admin/plugin/attributes`)
    }
  })

  // Query for categories
  const {
    data: categoriesData,
    isLoading: categoriesLoading
  } = useQuery({
    queryKey: ["admin-categories"],
    queryFn: async () => {
      return await sdk.client.fetch(`/admin/product-categories`, {
        query: {
          include_descendants_tree: true
        }
      })
    }
  })

  // Create mutation
  const createAttributeMutation = useMutation({
    mutationFn: async (payload: any) => {
      return await sdk.client.fetch(`/admin/plugin/attributes`, {
        method: "POST",
        body: payload
      })
    },
    onSuccess: () => {
      toast.success("Success", { description: "Attribute created successfully" })
      setIsDrawerOpen(false)
      refetchAttributes()
    },
    onError: (error) => {
      console.error('Error creating attribute:', error)
      toast.error("Error", { description: "Failed to create attribute" })
    }
  })

  // Update mutation
  const updateAttributeMutation = useMutation({
    mutationFn: async ({ id, payload }: { id: string, payload: any }) => {
      return await sdk.client.fetch(`/admin/plugin/attributes/${id}`, {
        method: "POST",
        body: payload
      })
    },
    onSuccess: () => {
      toast.success("Success", { description: "Attribute updated successfully" })
      setIsDrawerOpen(false)
      refetchAttributes()
    },
    onError: (error) => {
      console.error('Error updating attribute:', error)
      toast.error("Error", { description: "Failed to update attribute" })
    }
  })

  // Delete mutation
  const deleteAttributeMutation = useMutation({
    mutationFn: async (id: string) => {
      return await sdk.client.fetch(`/admin/plugin/attributes/${id}`, {
        method: "DELETE"
      })
    },
    onSuccess: () => {
      toast.success("Success", { description: "Attribute deleted successfully" })
      refetchAttributes()
    },
    onError: (error) => {
      console.error('Error deleting attribute:', error)
      toast.error("Error", { description: "Failed to delete attribute" })
    }
  })

  // Bulk delete mutation
  const bulkDeleteMutation = useMutation({
    mutationFn: async (ids: string[]) => {
      return await sdk.client.fetch(`/admin/plugin/attributes/bulk-delete`, {
        method: "POST",
        body: { ids }
      })
    },
    onSuccess: (_, ids) => {
      toast.success("Success", { description: `${ids.length} attributes deleted successfully` })
      setSelectedRows(new Set())
      refetchAttributes()
    },
    onError: (error) => {
      console.error('Error deleting attributes:', error)
      toast.error("Error", { description: "Failed to delete attributes" })
    }
  })

  const attributes = attributesData?.attributes || []
  const categories = categoriesData?.product_categories || []
  const loading = attributesLoading || categoriesLoading

  const handleCreate = () => {
    setEditingAttribute(null)
    setFormData({
      name: '',
      description: '',
      handle: '',
      is_filterable: true,
      possible_values: [{ value: '', rank: 1 }],
      product_category_ids: []
    })
    setIsDrawerOpen(true)
  }

  const handleEdit = (attribute: Attribute) => {
    setEditingAttribute(attribute)
    setFormData({
      name: attribute.name,
      description: attribute.description || '',
      handle: attribute.handle,
      is_filterable: attribute.is_filterable,
      possible_values: attribute.possible_values?.length
        ? attribute.possible_values
        : [{ value: '', rank: 1 }],
      product_category_ids: attribute.product_categories?.map(c => c.id) || []
    })
    setIsDrawerOpen(true)
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()

    const payload = {
      name: formData.name,
      description: formData.description || undefined,
      handle: formData.handle || undefined,
      is_filterable: formData.is_filterable,
      possible_values: formData.possible_values.filter(pv => pv.value.trim()),
      product_category_ids: formData.product_category_ids.length > 0 ? formData.product_category_ids : undefined
    }

    if (editingAttribute) {
      updateAttributeMutation.mutate({ id: editingAttribute.id, payload })
    } else {
      createAttributeMutation.mutate(payload)
    }
  }

  const handleDelete = async (id: string) => {
    const confirmed = await prompt({
      title: "Delete Attribute",
      description: "Are you sure you want to delete this attribute? This action cannot be undone.",
      confirmText: "Delete",
      cancelText: "Cancel"
    })

    if (confirmed) {
      deleteAttributeMutation.mutate(id)
    }
  }

  const handleBulkDelete = async () => {
    if (selectedRows.size === 0) return

    const confirmed = await prompt({
      title: "Delete Attributes",
      description: `Are you sure you want to delete ${selectedRows.size} attribute(s)? This action cannot be undone.`,
      confirmText: "Delete",
      cancelText: "Cancel"
    })

    if (confirmed) {
      bulkDeleteMutation.mutate(Array.from(selectedRows))
    }
  }

  const addPossibleValue = () => {
    setFormData(prev => ({
      ...prev,
      possible_values: [
        ...prev.possible_values,
        { value: '', rank: prev.possible_values.length + 1 }
      ]
    }))
  }

  const updatePossibleValue = (index: number, value: string) => {
    setFormData(prev => ({
      ...prev,
      possible_values: prev.possible_values.map((pv, i) =>
        i === index ? { ...pv, value } : pv
      )
    }))
  }

  const removePossibleValue = (index: number) => {
    setFormData(prev => ({
      ...prev,
      possible_values: prev.possible_values.filter((_, i) => i !== index)
    }))
  }

  const toggleRowSelection = (id: string) => {
    setSelectedRows(prev => {
      const newSet = new Set(prev)
      if (newSet.has(id)) {
        newSet.delete(id)
      } else {
        newSet.add(id)
      }
      return newSet
    })
  }

  const toggleAllRows = () => {
    if (selectedRows.size === attributes.length) {
      setSelectedRows(new Set())
    } else {
      setSelectedRows(new Set(attributes.map(attr => attr.id)))
    }
  }

  // Helper function to find category by ID in nested structure
  const findCategoryById = (categories: Category[], id: string): Category | null => {
    for (const category of categories) {
      if (category.id === id) {
        return category
      }
      if (category.category_children?.length) {
        const found = findCategoryById(category.category_children, id)
        if (found) return found
      }
    }
    return null
  }

  const isSubmitting = createAttributeMutation.isPending || updateAttributeMutation.isPending

  if (loading) {
    return (
      <Container>
        <div className="flex items-center justify-center h-64">
          <Text>Loading attributes...</Text>
        </div>
      </Container>
    )
  }

  return (
    <Container>
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div>
          <Heading level="h1">Attributes</Heading>
          <Text className="text-ui-fg-subtle">
            Manage product attributes and their possible values
          </Text>
        </div>
        <div className="flex items-center gap-2">
          {selectedRows.size > 0 && (
            <Button
              variant="danger"
              onClick={handleBulkDelete}
              isLoading={bulkDeleteMutation.isPending}
            >
              <Trash className="mr-2" />
              Delete ({selectedRows.size})
            </Button>
          )}
          <Button onClick={handleCreate}>
            <Plus className="mr-2" />
            Create Attribute
          </Button>
        </div>
      </div>

      {/* Table */}
      <div className="bg-ui-bg-base border border-ui-border-base rounded-lg overflow-hidden">
        <Table>
          <Table.Header>
            <Table.Row>
              <Table.HeaderCell className="w-12">
                <Checkbox
                  checked={selectedRows.size === attributes.length && attributes.length > 0}
                  onCheckedChange={toggleAllRows}
                />
              </Table.HeaderCell>
              <Table.HeaderCell>Name</Table.HeaderCell>
              <Table.HeaderCell>Properties</Table.HeaderCell>
              <Table.HeaderCell>Values</Table.HeaderCell>
              <Table.HeaderCell>Categories</Table.HeaderCell>
              <Table.HeaderCell>Created</Table.HeaderCell>
              <Table.HeaderCell className="w-20">Actions</Table.HeaderCell>
            </Table.Row>
          </Table.Header>
          <Table.Body>
            {attributes.map((attribute) => (
              <Table.Row key={attribute.id}>
                <Table.Cell>
                  <Checkbox
                    checked={selectedRows.has(attribute.id)}
                    onCheckedChange={() => toggleRowSelection(attribute.id)}
                  />
                </Table.Cell>
                <Table.Cell>
                  <div>
                    <Text weight="plus" className="mb-1">
                      {attribute.name}
                    </Text>
                    <Text size="small" className="text-ui-fg-subtle">
                      {attribute.handle}
                    </Text>
                    {attribute.description && (
                      <Text size="small" className="text-ui-fg-muted mt-1">
                        {attribute.description}
                      </Text>
                    )}
                  </div>
                </Table.Cell>
                <Table.Cell>
                  <div className="flex gap-1">
                    {attribute.is_filterable && (
                      <Badge color="blue">Filterable</Badge>
                    )}
                  </div>
                </Table.Cell>
                <Table.Cell>
                  <Text size="small">
                    {attribute.possible_values?.length || 0} possible values
                  </Text>
                </Table.Cell>
                <Table.Cell>
                  <Text size="small">
                    {attribute.product_categories?.length
                      ? `${attribute.product_categories.length} categories`
                      : "Global"
                    }
                  </Text>
                </Table.Cell>
                <Table.Cell>
                  <Text size="small">
                    {attribute.created_at
                      ? new Date(attribute.created_at).toLocaleDateString()
                      : "—"
                    }
                  </Text>
                </Table.Cell>
                <Table.Cell>
                  <div className="flex items-center gap-1">
                    <IconButton
                      variant="transparent"
                      onClick={() => handleEdit(attribute)}
                    >
                      <PencilSquare />
                    </IconButton>
                    <IconButton
                      variant="transparent"
                      onClick={() => handleDelete(attribute.id)}
                      isLoading={deleteAttributeMutation.isPending}
                    >
                      <Trash />
                    </IconButton>
                  </div>
                </Table.Cell>
              </Table.Row>
            ))}
          </Table.Body>
        </Table>

        {attributes.length === 0 && (
          <div className="flex items-center justify-center h-32">
            <div className="text-center">
              <Text className="text-ui-fg-muted mb-2">No attributes found</Text>
              <Button variant="secondary" onClick={handleCreate}>
                Create your first attribute
              </Button>
            </div>
          </div>
        )}
      </div>

      {/* Create/Edit Drawer */}
      <Drawer open={isDrawerOpen} onOpenChange={setIsDrawerOpen}>
        <Drawer.Content className="max-h-[90vh]">
          <Drawer.Header>
            <Drawer.Title>
              {editingAttribute ? 'Edit Attribute' : 'Create Attribute'}
            </Drawer.Title>
          </Drawer.Header>

          <form onSubmit={handleSubmit} className="flex flex-col h-full max-h-[calc(90vh-120px)]">
            <Drawer.Body className="flex-1 overflow-y-auto px-6">
              <div className="space-y-6 pb-6">
                {/* Basic Information */}
                <div className="space-y-4">
                  <Heading level="h3">Basic Information</Heading>

                  <div>
                    <Label htmlFor="name" className="mb-2">Name *</Label>
                    <Input
                      id="name"
                      value={formData.name}
                      onChange={(e) => setFormData(prev => ({
                        ...prev,
                        name: e.target.value,
                        handle: prev.handle || e.target.value.toLowerCase().replace(/\s+/g, '-')
                      }))}
                      placeholder="e.g., Color, Size, Material"
                      required
                    />
                  </div>

                  <div>
                    <Label htmlFor="handle" className="mb-2">Handle</Label>
                    <Input
                      id="handle"
                      value={formData.handle}
                      onChange={(e) => setFormData(prev => ({ ...prev, handle: e.target.value }))}
                      placeholder="color, size, material"
                    />
                  </div>

                  <div>
                    <Label htmlFor="description" className="mb-2">Description</Label>
                    <Textarea
                      id="description"
                      value={formData.description}
                      onChange={(e) => setFormData(prev => ({ ...prev, description: e.target.value }))}
                      placeholder="Optional description for this attribute"
                    />
                  </div>
                </div>

                {/* Properties */}
                <div className="space-y-4">
                  <Heading level="h3">Properties</Heading>

                  <div className="flex items-center justify-between">
                    <div>
                      <Label>Filterable</Label>
                      <Text size="small" className="text-ui-fg-subtle">
                        Available for filtering products in the storefront
                      </Text>
                    </div>
                    <Switch
                      checked={formData.is_filterable}
                      onCheckedChange={(checked) =>
                        setFormData(prev => ({ ...prev, is_filterable: checked }))
                      }
                    />
                  </div>
                </div>

                {/* Categories */}
                <div className="space-y-4">
                  <Heading level="h3">Categories</Heading>
                  <Text size="small" className="text-ui-fg-subtle">
                    Leave empty to make this attribute global (available for all products)
                  </Text>

                  <CategoryCombobox
                    value={formData.product_category_ids}
                    onChange={(values) =>
                      setFormData(prev => ({ ...prev, product_category_ids: values }))
                    }
                    categories={categories}
                    placeholder="Search and select categories..."
                  />

                  {formData.product_category_ids.length > 0 && (
                    <div className="flex flex-wrap gap-1 max-h-24 overflow-y-auto">
                      {formData.product_category_ids.map(categoryId => {
                        const category = findCategoryById(categories, categoryId)
                        return category ? (
                          <Badge key={categoryId} color="orange">
                            {category.name}
                          </Badge>
                        ) : null
                      })}
                    </div>
                  )}
                </div>

                {/* Possible Values */}
                <div className="space-y-4">
                  <div className="flex items-center justify-between">
                    <Heading level="h3">Possible Values</Heading>
                    <Button type="button" variant="secondary" onClick={addPossibleValue}>
                      <Plus className="mr-2" />
                      Add Value
                    </Button>
                  </div>
                  <Text size="small" className="text-ui-fg-subtle">
                    Define predefined values for this attribute. Leave empty to allow any value.
                  </Text>

                  <div className="space-y-3 max-h-64 overflow-y-auto">
                    {formData.possible_values.map((pv, index) => (
                      <div key={index} className="flex items-center gap-2">
                        <Input
                          value={pv.value}
                          onChange={(e) => updatePossibleValue(index, e.target.value)}
                          placeholder={`Value ${index + 1}`}
                        />
                        {formData.possible_values.length > 1 && (
                          <IconButton
                            type="button"
                            variant="transparent"
                            onClick={() => removePossibleValue(index)}
                          >
                            <Trash />
                          </IconButton>
                        )}
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </Drawer.Body>

            <Drawer.Footer className="flex-shrink-0 border-t border-ui-border-base">
              <div className="flex justify-end gap-2 p-6">
                <Button
                  type="button"
                  variant="secondary"
                  onClick={() => setIsDrawerOpen(false)}
                >
                  Cancel
                </Button>
                <Button type="submit" isLoading={isSubmitting}>
                  {editingAttribute ? 'Update' : 'Create'} Attribute
                </Button>
              </div>
            </Drawer.Footer>
          </form>
        </Drawer.Content>
      </Drawer>
    </Container>
  )
}

export const config = defineRouteConfig({
  label: "Attributes",
  icon: Tag,
})

export default AttributesPage
```

## File: src/admin/widgets/category-attributes.tsx
```typescript
import { defineWidgetConfig } from "@medusajs/admin-sdk"
import { useState, useEffect } from "react"
import {
  Container,
  Heading,
  Button,
  Badge,
  Text,
  IconButton,
  Label,
  Checkbox,
  toast
} from "@medusajs/ui"
import { Trash, Plus, ExclamationCircle } from "@medusajs/icons"

interface Attribute {
  id: string
  name: string
  description?: string
  handle: string
  is_variant_defining: boolean
  is_filterable: boolean
  possible_values?: Array<{
    id: string
    value: string
    rank: number
  }>
  product_categories?: Array<{
    id: string
    name: string
  }>
}

interface CategoryAttribute {
  id: string
  name: string
  description?: string
  handle: string
  is_variant_defining: boolean
  is_filterable: boolean
  possible_values?: Array<{
    id: string
    value: string
    rank: number
  }>
}

const CategoryAttributesWidget = () => {
  const [allAttributes, setAllAttributes] = useState<Attribute[]>([])
  const [categoryAttributes, setCategoryAttributes] = useState<CategoryAttribute[]>([])
  const [globalAttributes, setGlobalAttributes] = useState<CategoryAttribute[]>([])
  const [loading, setLoading] = useState(true)
  const [saving, setSaving] = useState(false)
  const [selectedAttributeIds, setSelectedAttributeIds] = useState<Set<string>>(new Set())

  // Get category ID from URL
  const getCategoryId = () => {
    const path = window.location.pathname
    const matches = path.match(/\/categories\/([^\/]+)/)
    return matches?.[1]
  }

  const categoryId = getCategoryId()

  useEffect(() => {
    if (categoryId) {
      fetchData()
    }
  }, [categoryId])

  const fetchData = async () => {
    try {
      setLoading(true)

      // Fetch all attributes
      const attributesResponse = await fetch('/admin/plugin/attributes', {
        credentials: 'include'
      })
      const attributesData = await attributesResponse.json()
      const attributes = attributesData.attributes || []
      setAllAttributes(attributes)

      // Separate category-specific and global attributes
      const categorySpecific = attributes.filter((attr: Attribute) =>
        attr.product_categories?.some(cat => cat.id === categoryId)
      )
      const global = attributes.filter((attr: Attribute) =>
        !attr.product_categories?.length
      )

      setCategoryAttributes(categorySpecific)
      setGlobalAttributes(global)

    } catch (error) {
      console.error('Error fetching attributes:', error)
      toast.error("Failed to load attributes")
    } finally {
      setLoading(false)
    }
  }

  const handleAttributeToggle = (attributeId: string) => {
    setSelectedAttributeIds(prev => {
      const newSet = new Set(prev)
      if (newSet.has(attributeId)) {
        newSet.delete(attributeId)
      } else {
        newSet.add(attributeId)
      }
      return newSet
    })
  }

  const assignAttributesToCategory = async () => {
    if (!categoryId || selectedAttributeIds.size === 0) return

    setSaving(true)
    try {
      // Update each selected attribute to include this category
      await Promise.all(
        Array.from(selectedAttributeIds).map(async (attributeId) => {
          const attribute = allAttributes.find(attr => attr.id === attributeId)
          if (!attribute) return

          const currentCategoryIds = attribute.product_categories?.map(cat => cat.id) || []
          const updatedCategoryIds = [...currentCategoryIds, categoryId]

          await fetch(`/admin/plugin/attributes/${attributeId}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            credentials: 'include',
            body: JSON.stringify({
              product_category_ids: updatedCategoryIds
            })
          })
        })
      )

      // Clear selections and refresh
      setSelectedAttributeIds(new Set())
      await fetchData()
      toast.success("Attributes assigned successfully")
    } catch (error) {
      console.error('Error assigning attributes:', error)
      toast.error("Failed to assign attributes")
    } finally {
      setSaving(false)
    }
  }

  const removeAttributeFromCategory = async (attributeId: string) => {
    if (!categoryId) return

    try {
      const attribute = allAttributes.find(attr => attr.id === attributeId)
      if (!attribute) return

      const currentCategoryIds = attribute.product_categories?.map(cat => cat.id) || []
      const updatedCategoryIds = currentCategoryIds.filter(id => id !== categoryId)

      await fetch(`/admin/plugin/attributes/${attributeId}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify({
          product_category_ids: updatedCategoryIds
        })
      })

      await fetchData()
      toast.success("Attribute removed from category")
    } catch (error) {
      console.error('Error removing attribute from category:', error)
      toast.error("Failed to remove attribute")
    }
  }

  const getAvailableAttributes = () => {
    return allAttributes.filter(attr =>
      !categoryAttributes.some(catAttr => catAttr.id === attr.id) &&
      !globalAttributes.some(globalAttr => globalAttr.id === attr.id)
    )
  }

  if (loading) {
    return (
      <Container>
        <div className="flex items-center justify-center py-8">
          <Text size="small" className="text-ui-fg-muted">Loading attributes...</Text>
        </div>
      </Container>
    )
  }

  if (!categoryId) {
    return (
      <Container>
        <div className="flex items-center gap-2 py-6">
          <ExclamationCircle className="text-ui-fg-muted" />
          <Text size="small" className="text-ui-fg-muted">
            Category ID not found
          </Text>
        </div>
      </Container>
    )
  }

  const availableAttributes = getAvailableAttributes()
  const hasAnyAttributes = categoryAttributes.length > 0 || globalAttributes.length > 0 || availableAttributes.length > 0

  return (
    <Container className="px-0">
      <div className="space-y-4">
        {/* Header */}
        <div className="flex items-center justify-between px-6">
          <div>
            <Heading level="h3" className="text-ui-fg-base">
              Attributes
            </Heading>
            <Text size="small" className="text-ui-fg-subtle">
              Manage category-specific and global attributes
            </Text>
          </div>
          {selectedAttributeIds.size > 0 && (
            <Button
              variant="secondary"
              size="small"
              onClick={assignAttributesToCategory}
              isLoading={saving}
            >
              <Plus className="mr-1.5" />
              Assign {selectedAttributeIds.size}
            </Button>
          )}
        </div>

        {!hasAnyAttributes ? (
          <div className="flex flex-col items-center justify-center py-12 px-6">
            <Text className="text-ui-fg-muted mb-2">
              No attributes found
            </Text>
            <Text size="small" className="text-ui-fg-subtle text-center">
              Create attributes to assign them to this category
            </Text>
          </div>
        ) : (
          <div className="space-y-4">
            {/* Category-Specific Attributes */}
            {categoryAttributes.length > 0 && (
              <div className="border-t border-ui-border-base">
                <div className="px-6 py-3 bg-ui-bg-subtle">
                  <Label className="text-xs font-medium text-ui-fg-subtle uppercase tracking-wide">
                    Category Attributes ({categoryAttributes.length})
                  </Label>
                </div>
                <div className="divide-y divide-ui-border-base">
                  {categoryAttributes.map((attribute) => (
                    <div
                      key={attribute.id}
                      className="flex items-center justify-between px-6 py-3 hover:bg-ui-bg-subtle transition-colors"
                    >
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center gap-2 mb-1">
                          <Text size="small" weight="plus" className="truncate">
                            {attribute.name}
                          </Text>
                          <div className="flex gap-1">
                            {attribute.is_variant_defining && (
                              <Badge color="purple" size="2xsmall">V</Badge>
                            )}
                            {attribute.is_filterable && (
                              <Badge color="blue" size="2xsmall">F</Badge>
                            )}
                          </div>
                        </div>
                        <div className="flex items-center gap-3">
                          <Text size="xsmall" className="text-ui-fg-subtle">
                            {attribute.handle}
                          </Text>
                          <Badge color="orange" size="2xsmall">
                            {attribute.possible_values?.length || 0} values
                          </Badge>
                        </div>
                      </div>
                      <IconButton
                        variant="transparent"
                        size="small"
                        onClick={() => removeAttributeFromCategory(attribute.id)}
                        className="text-ui-fg-muted hover:text-ui-fg-subtle"
                      >
                        <Trash />
                      </IconButton>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* Global Attributes */}
            {globalAttributes.length > 0 && (
              <div className="border-t border-ui-border-base">
                <div className="px-6 py-3 bg-ui-bg-field">
                  <Label className="text-xs font-medium text-ui-fg-subtle uppercase tracking-wide">
                    Global Attributes ({globalAttributes.length})
                  </Label>
                </div>
                <div className="divide-y divide-ui-border-base">
                  {globalAttributes.map((attribute) => (
                    <div
                      key={attribute.id}
                      className="flex items-center px-6 py-3"
                    >
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center gap-2 mb-1">
                          <Text size="small" weight="plus" className="truncate">
                            {attribute.name}
                          </Text>
                          <div className="flex gap-1">
                            {attribute.is_variant_defining && (
                              <Badge color="purple" size="2xsmall">V</Badge>
                            )}
                            {attribute.is_filterable && (
                              <Badge color="blue" size="2xsmall">F</Badge>
                            )}
                            <Badge color="green" size="2xsmall">Global</Badge>
                          </div>
                        </div>
                        <div className="flex items-center gap-3">
                          <Text size="xsmall" className="text-ui-fg-subtle">
                            {attribute.handle}
                          </Text>
                          <Badge color="orange" size="2xsmall">
                            {attribute.possible_values?.length || 0} values
                          </Badge>
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* Available Attributes */}
            {availableAttributes.length > 0 && (
              <div className="border-t border-ui-border-base">
                <div className="px-6 py-3 bg-ui-bg-base">
                  <Label className="text-xs font-medium text-ui-fg-subtle uppercase tracking-wide">
                    Available to Assign ({availableAttributes.length})
                  </Label>
                </div>
                <div className="divide-y divide-ui-border-base">
                  {availableAttributes.map((attribute) => (
                    <div
                      key={attribute.id}
                      className="flex items-center px-6 py-3 hover:bg-ui-bg-subtle transition-colors"
                    >
                      <Checkbox
                        checked={selectedAttributeIds.has(attribute.id)}
                        onCheckedChange={() => handleAttributeToggle(attribute.id)}
                        className="mr-3"
                      />
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center gap-2 mb-1">
                          <Text size="small" weight="plus" className="truncate">
                            {attribute.name}
                          </Text>
                          <div className="flex gap-1">
                            {attribute.is_variant_defining && (
                              <Badge color="purple" size="2xsmall">V</Badge>
                            )}
                            {attribute.is_filterable && (
                              <Badge color="blue" size="2xsmall">F</Badge>
                            )}
                          </div>
                        </div>
                        <div className="flex items-center gap-3">
                          <Text size="xsmall" className="text-ui-fg-subtle">
                            {attribute.handle}
                          </Text>
                          <Badge color="orange" size="2xsmall">
                            {attribute.possible_values?.length || 0} values
                          </Badge>
                          {attribute.product_categories?.length && (
                            <Badge color="grey" size="2xsmall">
                              {attribute.product_categories.length} categories
                            </Badge>
                          )}
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}

        {/* Footer Info */}
        {hasAnyAttributes && (
          <div className="border-t border-ui-border-base px-6 py-3">
            <Text size="xsmall" className="text-ui-fg-muted">
              Category attributes are specific to products in this category.
              Global attributes are available to all products.
            </Text>
          </div>
        )}
      </div>
    </Container>
  )
}

export const config = defineWidgetConfig({
  zone: "product_category.details.after",
})

export default CategoryAttributesWidget
```

## File: src/admin/widgets/product-attributes.tsx
```typescript
import { defineWidgetConfig } from "@medusajs/admin-sdk"
import { useState, useEffect } from "react"
import {
  Container,
  Heading,
  Button,
  Select,
  Input,
  Badge,
  Text,
  IconButton,

  Label
} from "@medusajs/ui"
import {Trash, Plus} from "@medusajs/icons"
import { sdk } from "../lib/sdk"

interface Attribute {
  id: string
  name: string
  description?: string

  handle: string
  is_filterable: boolean
  possible_values?: Array<{
    id: string
    value: string
    rank: number

  }>
}

interface AttributeValue {
  id: string
  value: string
  attribute: Attribute
}

interface ProductAttributeAssignment {
  attribute_id: string
  value: string
  temp_id?: string // For new assignments
}

const ProductAttributesWidget = () => {
  const [attributes, setAttributes] = useState<Attribute[]>([])
  const [productAttributes, setProductAttributes] = useState<AttributeValue[]>([])
  const [assignments, setAssignments] = useState<ProductAttributeAssignment[]>([])
  const [loading, setLoading] = useState(true)
  const [saving, setSaving] = useState(false)

  // Get product ID from URL
  const getProductId = () => {
    const path = window.location.pathname
    const matches = path.match(/\/products\/([^\/]+)/)
    return matches?.[1]
  }

  const productId = getProductId()

  useEffect(() => {
    if (productId) {
      fetchData()
    }
  }, [productId])

  const fetchData = async () => {
    try {
      setLoading(true)

      // Fetch available attributes using SDK

      const attributesData = await sdk.client.fetch('/admin/plugin/attributes')
      setAttributes(attributesData.attributes || [])

      // Fetch current product attribute values using SDK
      try {
        const productData = await sdk.client.fetch(`/admin/products/${productId}/attributes`)
        setProductAttributes(productData.attribute_values || [])
      } catch (error) {
        // If endpoint doesn't exist or no attributes, that's ok

        console.log('No existing product attributes found')
        setProductAttributes([])
      }

    } catch (error) {
      console.error('Error fetching attributes:', error)
    } finally {
      setLoading(false)
    }
  }

  const addAttributeAssignment = () => {
    setAssignments(prev => [...prev, {
      attribute_id: '',
      value: '',
      temp_id: `temp_${Date.now()}`
    }])
  }

  const updateAssignment = (index: number, field: keyof ProductAttributeAssignment, value: string) => {
    setAssignments(prev => prev.map((assignment, i) =>
      i === index ? { ...assignment, [field]: value } : assignment
    ))
  }

  const removeAssignment = (index: number) => {
    setAssignments(prev => prev.filter((_, i) => i !== index))
  }

  const removeExistingAttribute = async (attributeValueId: string) => {
    try {
      await sdk.client.fetch(`/admin/products/${productId}/attributes/${attributeValueId}`, {
        method: 'DELETE'
      })

      // Refresh data

      await fetchData()
    } catch (error) {
      console.error('Error removing attribute:', error)
    }
  }

  const saveAttributes = async () => {
    if (!productId) return

    setSaving(true)
    try {
      // Filter out empty assignments
      const validAssignments = assignments.filter(a => a.attribute_id && a.value.trim())

      // Save each assignment using SDK

      for (const assignment of validAssignments) {
        await sdk.client.fetch(`/admin/products/${productId}/attributes`, {
          method: 'POST',
          body: {
            attribute_id: assignment.attribute_id,
            value: assignment.value
          }
        })
      }

      // Clear assignments and refresh
      setAssignments([])
      await fetchData()
    } catch (error) {
      console.error('Error saving attributes:', error)
    } finally {
      setSaving(false)
    }
  }


  const getAvailableAttributes = () => {
    const usedAttributeIds = new Set([
      ...productAttributes.map(pa => pa.attribute.id),
      ...assignments.map(a => a.attribute_id).filter(Boolean)
    ])

    return attributes.filter(attr => !usedAttributeIds.has(attr.id))
  }


  const getAttributeById = (id: string) => {
    return attributes.find(attr => attr.id === id)
  }

  if (loading) {
    return (
      <Container>
        <Text>Loading attributes...</Text>
      </Container>
    )
  }

  if (!productId) {

    return (

      <Container>
        <Text className="text-ui-fg-muted">Product ID not found</Text>
      </Container>
    )
  }

  return (
    <Container>
      <div className="space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <Heading level="h2">Product Attributes</Heading>
          <Button
            variant="secondary"
            size="small"
            onClick={addAttributeAssignment}
            disabled={getAvailableAttributes().length === 0}
          >
            <Plus className="mr-2" />

            Add Attribute
          </Button>
        </div>

        {/* Current Attributes */}

        {productAttributes.length > 0 && (
          <div className="space-y-3">
            <Label>Current Attributes</Label>
            <div className="space-y-2">
              {productAttributes.map((attributeValue) => (
                <div
                  key={attributeValue.id}
                  className="flex items-center justify-between p-3 border border-ui-border-base rounded-lg bg-ui-bg-subtle"
                >
                  <div className="flex items-center gap-3">
                    <div>
                      <Text weight="plus" size="small">
                        {attributeValue.attribute.name}

                      </Text>
                      <Text size="small" className="text-ui-fg-subtle">
                        {attributeValue.value}
                      </Text>
                    </div>
                    <div className="flex gap-1">
                      {attributeValue.attribute.is_filterable && (
                        <Badge color="blue" size="small">Filterable</Badge>
                      )}
                    </div>
                  </div>

                  <IconButton
                    variant="transparent"
                    onClick={() => removeExistingAttribute(attributeValue.id)}
                  >
                    <Trash />
                  </IconButton>
                </div>

              ))}
            </div>
          </div>
        )}

        {/* New Assignments */}
        {assignments.length > 0 && (
          <div className="space-y-3">
            <Label>Add New Attributes</Label>
            <div className="space-y-3">
              {assignments.map((assignment, index) => {
                const selectedAttribute = getAttributeById(assignment.attribute_id)

                return (
                  <div key={assignment.temp_id || index} className="flex items-end gap-2">
                    <div className="flex-1">
                      <Label className="mb-2">Attribute</Label>
                      <Select
                        value={assignment.attribute_id}

                        onValueChange={(value) => updateAssignment(index, 'attribute_id', value)}
                      >
                        <Select.Trigger>
                          <Select.Value placeholder="Select attribute...">
                            {assignment.attribute_id && (
                              <div className="flex items-center gap-2">
                                <span>{getAttributeById(assignment.attribute_id)?.name}</span>
                                <div className="flex gap-1">
                                  {getAttributeById(assignment.attribute_id)?.is_filterable && (
                                    <Badge color="blue" size="small">F</Badge>
                                  )}
                                </div>
                              </div>
                            )}
                          </Select.Value>
                        </Select.Trigger>
                        <Select.Content>
                          {getAvailableAttributes().map((attribute) => (
                            <Select.Item key={attribute.id} value={attribute.id}>
                              <div className="flex items-center gap-2">
                                <span>{attribute.name}</span>
                                <div className="flex gap-1">
                                  {attribute.is_filterable && (
                                    <Badge color="blue" size="small">F</Badge>
                                  )}
                                </div>
                              </div>
                            </Select.Item>
                          ))}
                        </Select.Content>
                      </Select>
                    </div>

                    <div className="flex-1">
                      <Label className="mb-2">Value</Label>
                      {selectedAttribute?.possible_values?.length ? (
                        <Select
                          value={assignment.value}
                          onValueChange={(value) => updateAssignment(index, 'value', value)}
                        >
                          <Select.Trigger>
                            <Select.Value placeholder="Select value...">
                              {assignment.value && <span>{assignment.value}</span>}
                            </Select.Value>
                          </Select.Trigger>
                          <Select.Content>
                            {selectedAttribute.possible_values
                              .sort((a, b) => a.rank - b.rank)
                              .map((pv) => (

                              <Select.Item key={pv.id} value={pv.value}>
                                {pv.value}
                              </Select.Item>
                            ))}
                          </Select.Content>
                        </Select>
                      ) : (
                        <Input
                          placeholder="Enter custom value..."
                          value={assignment.value}
                          onChange={(e) => updateAssignment(index, 'value', e.target.value)}
                        />
                      )}
                    </div>

                    <IconButton
                      variant="transparent"
                      onClick={() => removeAssignment(index)}
                    >
                      <Trash />
                    </IconButton>
                  </div>
                )
              })}
            </div>

            <div className="flex justify-end gap-2">
              <Button
                variant="secondary"
                onClick={() => setAssignments([])}
              >
                Cancel
              </Button>
              <Button
                onClick={saveAttributes}
                isLoading={saving}
                disabled={assignments.every(a => !a.attribute_id || !a.value.trim())}

              >
                Save Attributes
              </Button>
            </div>
          </div>

        )}

        {/* Empty State */}
        {productAttributes.length === 0 && assignments.length === 0 && (

          <div className="text-center py-8">
            <Text className="text-ui-fg-muted mb-4">
              No attributes assigned to this product
            </Text>
            <Button
              variant="secondary"

              onClick={addAttributeAssignment}
              disabled={attributes.length === 0}
            >
              {attributes.length === 0 ? 'No attributes available' : 'Add First Attribute'}
            </Button>
          </div>
        )}

        {/* Helper Text */}

        <div className="text-xs text-ui-fg-muted border-t pt-4">

          <Text size="small">
            <strong>Tip:</strong> Filterable attributes will be available for customer filtering in the storefront.
          </Text>
        </div>
      </div>
    </Container>
  )
}

export const config = defineWidgetConfig({
  zone: "product.details.after",
})

export default ProductAttributesWidget
```

## File: src/admin/README.md
```markdown
# Admin Customizations

You can extend the Medusa Admin to add widgets and new pages. Your customizations interact with API routes to provide merchants with custom functionalities.

## Example: Create a Widget

A widget is a React component that can be injected into an existing page in the admin dashboard.

For example, create the file `src/admin/widgets/product-widget.tsx` with the following content:

```tsx title="src/admin/widgets/product-widget.tsx"
import { defineWidgetConfig } from "@medusajs/admin-sdk"

// The widget
const ProductWidget = () => {
  return (
    <div>
      <h2>Product Widget</h2>
    </div>
  )
}

// The widget's configurations
export const config = defineWidgetConfig({
  zone: "product.details.after",
})

export default ProductWidget
```

This inserts a widget with the text “Product Widget” at the end of a product’s details page.
```

## File: src/admin/tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["."]
}
```

## File: src/admin/vite-env.d.ts
```typescript
/// <reference types="vite/client" />
```

## File: src/api/admin/plugin/attribute-set/[id]/middlewares.ts
```typescript
import { MiddlewareRoute, validateAndTransformBody, validateAndTransformQuery } from "@medusajs/framework"
import {  AdminGetAttributeSetParams, AdminUpdateAttributeSet } from "../validators"
import { retrieveAttributeSetQueryConfig } from "../query-config"

export const adminAttributeSetDetailMiddlewares: MiddlewareRoute[] = [
  {
    method: ['GET'],
    matcher: '/admin/plugin/attribute-set/:id',

    middlewares: [
      validateAndTransformQuery(
        AdminGetAttributeSetParams,
        retrieveAttributeSetQueryConfig
      )
    ]
  },
  {

    method: ['POST'],
    matcher: '/admin/plugin/attribute-set/:id',
    middlewares: [
      // validateAndTransformBody(AdminUpdateAttributeSetType),
      validateAndTransformBody(AdminUpdateAttributeSet),

      validateAndTransformQuery(
        AdminGetAttributeSetParams,
        retrieveAttributeSetQueryConfig

      )
    ]
  },
  {
    method: ['DELETE'],
    matcher: '/admin/plugin/attribute-set/:id',
    middlewares: []
  }
]
```

## File: src/api/admin/plugin/attribute-set/middlewares.ts
```typescript
import { AdminCreateAttributeSet, AdminGetAttributeSetParams } from "./validators";
import { MiddlewareRoute, validateAndTransformBody, validateAndTransformQuery } from "@medusajs/framework";

import { retrieveAttributeSetQueryConfig } from "./query-config";

export const adminAttributeSetMiddlewares: MiddlewareRoute[] = [
    {
        matcher: '/admin/plugin/attribute-set',
        methods: ['POST'],
        middlewares: [
            validateAndTransformQuery(AdminGetAttributeSetParams, retrieveAttributeSetQueryConfig),
            validateAndTransformBody(AdminCreateAttributeSet)
        ]
    }
]
```

## File: src/api/admin/plugin/attribute-set/query-config.ts
```typescript
export const defaultAdminAttributeSetFields = [
    'id',
    'name',
    'description',
    'handle',
    'metadata',
    '*attributes',
    '*attributes.possible_values',
]

export const retrieveAttributeSetQueryConfig = {
    defaults: defaultAdminAttributeSetFields,
    isList: false,
}

export const listAttributeQueryConfig = {
    ...retrieveAttributeSetQueryConfig,
    defaultLimit: 50,
    isList: true,
}
```

## File: src/api/admin/plugin/attribute-set/route.ts
```typescript
import { MedusaRequest, MedusaResponse, refetchEntity } from "@medusajs/framework";

import { AdminCreateAttributeSetType } from "./validators";
import { createAttributeSetWorkflow } from "../../../../workflows/attribute-set/workflows/create-attribute-set";

export const POST = async (req: MedusaRequest<AdminCreateAttributeSetType>, res: MedusaResponse) => {
    const { result: [attributeSet] } = await createAttributeSetWorkflow(req.scope).run({
        input: [req.validatedBody]
    })

    const response = await refetchEntity(
        'attribute_set',
        attributeSet.id,
        req.scope,
        req.queryConfig.fields,
    )
    
    return res.status(201).json({ attribute_set: response })
}
```

## File: src/api/admin/plugin/attribute-set/validators.ts
```typescript
import { createSelectParams } from '@medusajs/medusa/api/utils/validators'
import { z } from 'zod'

const AdminBaseAttributeSet = z.object({
    name: z.string().optional(),
    description: z.string().optional(),
    handle: z.string().optional(),
    metadata: z.record(z.unknown()).nullish(),
    attributes: z.array(z.string()).optional(),
}).strict()

export type AdminCreateAttributeSetType = z.infer<typeof AdminCreateAttributeSet>
export const AdminCreateAttributeSet = AdminBaseAttributeSet.merge(z.object({
    name: z.string(),
})).strict()

export type AdminUpdateAttributeSetType = z.infer<typeof AdminUpdateAttributeSet>
export const AdminUpdateAttributeSet = AdminBaseAttributeSet

export const AdminGetAttributeSetParams = createSelectParams()
```

## File: src/api/admin/plugin/attributes/[id]/values/[valueId]/middlewares.ts
```typescript
import { MiddlewareRoute, validateAndTransformQuery } from "@medusajs/framework"
import { AdminGetAttributeValueParams } from "../../../validators"
import { retrieveAttributeValueQueryConfig } from "../../../query-config"

export const adminAttributeValueMiddlewares: MiddlewareRoute[] = [

  {
    method: ['GET'],
    matcher: '/admin/plugin/attributes/:id/values/:valueId',
    middlewares: [
      validateAndTransformQuery(
        AdminGetAttributeValueParams,
        retrieveAttributeValueQueryConfig
      )
    ]
  },
  {
    method: ['DELETE'],
    matcher: '/admin/plugin/attributes/:id/values/:valueId',
    middlewares: []
  }
]
```

## File: src/api/admin/plugin/attributes/[id]/values/[valueId]/route.ts
```typescript
import { ContainerRegistrationKeys, MedusaError, MedusaErrorTypes } from "@medusajs/framework/utils";
import { MedusaRequest, MedusaResponse } from "@medusajs/framework";

import { AdminGetAttributeValueParamsType } from "../../../validators";

export const GET = async (req: MedusaRequest<AdminGetAttributeValueParamsType>, res: MedusaResponse) => {
    const attributeId = req.params.valueId
    const query = req.scope.resolve(ContainerRegistrationKeys.QUERY)

    const { data: [attributePossibleValue] } = await query.graph({
        entity: 'attribute_possible_value',
        ...req.queryConfig,
        filters: {
            ...req.filterableFields,
            id: attributeId
        }
    })

    if (!attributePossibleValue) {
        throw new MedusaError(MedusaErrorTypes.NOT_FOUND, `Attribute possible value with id '${attributeId}' was not found`)
    }

    return res.status(200).json({ attributePossibleValue })
}
```

## File: src/api/admin/plugin/attributes/[id]/values/route.ts
```typescript
import { AdminCreateAttributeValueType, AdminGetAttributeValuesParamsType } from "../../validators";
import { MedusaRequest, MedusaResponse, refetchEntities, refetchEntity } from "@medusajs/framework";

import { ContainerRegistrationKeys } from "@medusajs/framework/utils";
import { createAttributePossibleValuesWorkflow } from "../../../../../../workflows/attribute/workflows/create-attribute-possible-values";

export const GET = async (req: MedusaRequest<AdminGetAttributeValuesParamsType>, res: MedusaResponse) => {
    const query = req.scope.resolve(ContainerRegistrationKeys.QUERY)

    const { data: attributePossibleValues, metadata } = await query.graph({
        entity: 'attribute_possible_value',
        filters: {
            attribute_id: req.params.id
        },
        ...req.queryConfig
    })

    res.status(200).json({ attributePossibleValues, count: metadata?.count, offset: metadata?.skip, limit: metadata?.take })
}

export const POST = async (req: MedusaRequest<AdminCreateAttributeValueType>, res: MedusaResponse) => {
    const attributeId = req.params.id

    const { result: [createdAttributeValue] } = await createAttributePossibleValuesWorkflow(req.scope).run({
        input: [{
            ...req.validatedBody,
            attribute_id: attributeId
        }]
    })

    const attributePossibleValue = await refetchEntity(
        'attribute_possible_value',
        createdAttributeValue.id,
        req.scope,
        req.queryConfig.fields,
    )

    return res.status(201).json({ attributePossibleValue })
}
```

## File: src/api/admin/plugin/attributes/[id]/route.ts
```typescript
// src/api/admin/plugin/attributes/[id]/route.ts
import { MedusaRequest, MedusaResponse, refetchEntity } from "@medusajs/framework";
import { AdminGetAttributeParamsType, AdminUpdateAttributeType } from "../validators";
import { ContainerRegistrationKeys, MedusaError, MedusaErrorTypes } from "@medusajs/framework/utils";
import { updateAttributesWorkflow } from "../../../../../workflows";
import { deleteAttributeWorkflow } from "../../../../../workflows/attribute/workflows/delete-attribute";

export const POST = async (req: MedusaRequest<AdminUpdateAttributeType>, res: MedusaResponse) => {
    const query = req.scope.resolve(ContainerRegistrationKeys.QUERY)

    const attributeId = req.params.id

    const { data: [existingAttribute] } = await query.graph({
        entity: 'attribute',
        fields: ['id'],
        filters: {
            id: attributeId
        }
    })

    if (!existingAttribute) {
        throw new MedusaError(MedusaErrorTypes.NOT_FOUND, `Attribute with id '${attributeId}' not found`)
    }

    // The workflow now properly handles product_category_ids via links
    await updateAttributesWorkflow(req.scope).run({
        input: { attributes: [{
            ...req.validatedBody,
            id: attributeId
        }] }
    })

    // Refetch the updated attribute with its linked categories
    const attribute = await refetchEntity(
        'attribute',
        attributeId,
        req.scope,
        req.queryConfig.fields
    )

    return res.status(200).json({ attribute })
}

export const GET = async (req: MedusaRequest<AdminGetAttributeParamsType>, res: MedusaResponse) => {
    const query = req.scope.resolve(ContainerRegistrationKeys.QUERY)

    const attributeId = req.params.id

    const { data: [attribute] } = await query.graph({
        entity: 'attribute',
        ...req.queryConfig,
        filters: {
            id: attributeId,
        },
    })

    if (!attribute) {
        throw new MedusaError(MedusaErrorTypes.NOT_FOUND, 'Attribute not found')
    }

    return res.status(200).json({ attribute })
}

export const DELETE = async (req: MedusaRequest, res: MedusaResponse) => {
    const attributeId = req.params.id
    const query = req.scope.resolve(ContainerRegistrationKeys.QUERY)

    // Check if attribute exists
    const { data: [existingAttribute] } = await query.graph({
        entity: 'attribute',
        fields: ['id'],
        filters: {
            id: attributeId
        }
    })

    if (!existingAttribute) {
        throw new MedusaError(MedusaErrorTypes.NOT_FOUND, `Attribute with id '${attributeId}' not found`)
    }

    // Delete the attribute using workflow
    await deleteAttributeWorkflow(req.scope).run({
        input: [attributeId]
    })

    return res.status(200).json({
        message: "Attribute deleted successfully",
        deleted: true,
        id: attributeId
    })
}
```

## File: src/api/admin/plugin/attributes/bulk-delete/route.ts
```typescript
// src/api/admin/plugin/attributes/bulk-delete/route.ts
import { MedusaRequest, MedusaResponse } from "@medusajs/framework";
import { ContainerRegistrationKeys, MedusaError, MedusaErrorTypes } from "@medusajs/framework/utils";
import { deleteAttributeWorkflow } from "../../../../../workflows/attribute/workflows/delete-attribute";
import { z } from "zod";

const BulkDeleteAttributesSchema = z.object({
  ids: z.array(z.string()).min(1, "At least one attribute ID is required")
});

export const POST = async (req: MedusaRequest, res: MedusaResponse) => {
    const { ids } = BulkDeleteAttributesSchema.parse(req.body);
    const query = req.scope.resolve(ContainerRegistrationKeys.QUERY);

    // Verify all attributes exist
    const { data: existingAttributes } = await query.graph({
        entity: 'attribute',
        fields: ['id'],
        filters: {
            id: ids
        }
    });

    const existingIds = existingAttributes.map(attr => attr.id);
    const notFoundIds = ids.filter(id => !existingIds.includes(id));

    if (notFoundIds.length > 0) {
        throw new MedusaError(
            MedusaErrorTypes.NOT_FOUND,
            `Attributes not found: ${notFoundIds.join(', ')}`
        );
    }

    // Delete all attributes using workflow
    await deleteAttributeWorkflow(req.scope).run({
        input: ids
    });

    return res.status(200).json({
        message: `${ids.length} attributes deleted successfully`,
        deleted: true,
        ids: ids,
        count: ids.length
    });
};
```

## File: src/api/admin/plugin/attributes/middlewares.ts
```typescript
import { MiddlewareRoute, validateAndTransformBody, validateAndTransformQuery } from "@medusajs/framework";
import { AdminCreateAttribute, AdminCreateAttributeValue, AdminGetAttributeParams, AdminGetAttributesParams, AdminGetAttributeValueParams, AdminGetAttributeValuesParams, AdminUpdateAttribute } from "./validators";
import * as QueryConfig from './query-config'
import { adminAttributesRoutePath } from "../../../utils/constants";
import { z } from "zod";

const BulkDeleteAttributesSchema = z.object({
    ids: z.array(z.string()).min(1, "At least one attribute ID is required")
});

export const adminAttributeRoutesMiddlewares: MiddlewareRoute[] = [
    {
        method: ['GET'],
        matcher: adminAttributesRoutePath,
        middlewares: [
            validateAndTransformQuery(
                AdminGetAttributesParams,
                QueryConfig.listAttributeQueryConfig,
            )
        ]
    },
    {
        method: ['POST'],
        matcher: adminAttributesRoutePath,
        middlewares: [
            validateAndTransformBody(AdminCreateAttribute),
            validateAndTransformQuery(
                AdminGetAttributeParams,
                QueryConfig.retrieveAttributeQueryConfig
            )
        ]
    },
    {
        method: ['GET'],
        matcher: `${adminAttributesRoutePath}/:id`,
        middlewares: [
            validateAndTransformQuery(
                AdminGetAttributeParams,
                QueryConfig.retrieveAttributeQueryConfig
            )
        ]
    },
    {
        method: ['POST'],
        matcher: `${adminAttributesRoutePath}/:id`,
        middlewares: [
            validateAndTransformBody(AdminUpdateAttribute),
            validateAndTransformQuery(
                AdminGetAttributeParams,
                QueryConfig.retrieveAttributeQueryConfig
            )
        ]
    },
    {
        method: ['DELETE'],
        matcher: `${adminAttributesRoutePath}/:id`,
        middlewares: []
    },
    {
        method: ['POST'],
        matcher: `${adminAttributesRoutePath}/bulk-delete`,
        middlewares: [
            validateAndTransformBody(BulkDeleteAttributesSchema)
        ]
    },
    {
        method: ['GET'],
        matcher: `${adminAttributesRoutePath}/:id/values`,
        middlewares: [
            validateAndTransformQuery(
                AdminGetAttributeValuesParams,
                QueryConfig.listAttributeValueQueryConfig,
            )
        ]
    },
    {
        method: ['POST'],
        matcher: `${adminAttributesRoutePath}/:id/values`,
        middlewares: [
            validateAndTransformBody(AdminCreateAttributeValue),
            validateAndTransformQuery(
                AdminGetAttributeValueParams,
                QueryConfig.retrieveAttributeValueQueryConfig,
            )
        ]
    },
    {
        method: ['GET'],
        matcher: `${adminAttributesRoutePath}/:id/values/:valueId`,
        middlewares: [
            validateAndTransformQuery(
                AdminGetAttributeValueParams,
                QueryConfig.retrieveAttributeValueQueryConfig
            )
        ]
    },
]
```

## File: src/api/admin/plugin/attributes/query-config.ts
```typescript
export const defaultAdminAttributeFields = [
    'id',
    'name',
    'description',
    'is_filterable',
    'handle',
    'metadata',
    '*possible_values',
    '*product_categories'
]

export const retrieveAttributeQueryConfig = {
    defaults: defaultAdminAttributeFields,
    isList: false,
}

export const listAttributeQueryConfig = {
    ...retrieveAttributeQueryConfig,
    defaultLimit: 50,
    isList: true,
}

export const defaultAdminAttributeValueFields = [
    'id',
    'value',
    'rank',
]

export const retrieveAttributeValueQueryConfig = {
    defaults: defaultAdminAttributeValueFields,
    isList: false,
}

export const listAttributeValueQueryConfig = {
    ...retrieveAttributeValueQueryConfig,
    isList: true,
    defaultLimit: 50,
}
```

## File: src/api/admin/plugin/attributes/route.ts
```typescript
import { MedusaRequest, MedusaResponse, refetchEntities, refetchEntity } from "@medusajs/framework";
import { AdminCreateAttributeType, AdminGetAttributesParamsType } from "./validators";
import { createAttributesWorkflow } from "../../../../workflows";
import { ContainerRegistrationKeys } from "@medusajs/framework/utils";

export const GET = async (req: MedusaRequest<AdminGetAttributesParamsType>, res: MedusaResponse) => {
    const query = req.scope.resolve(ContainerRegistrationKeys.QUERY)
    // TODO: check why, even though *product_categories is in default fields
    // only the id is returned for each category
    const { data: attributes, metadata } = await query.graph({
        entity: 'attribute',
        ...req.queryConfig
    })
    return res.status(200).json({ attributes, count: metadata?.count, offset: metadata?.skip, limit: metadata?.take })
}

export const POST = async (req: MedusaRequest<AdminCreateAttributeType>, res: MedusaResponse) => {
    const attributeDto = req.validatedBody

    const { result } = await createAttributesWorkflow(req.scope).run({
        input: { attributes: [attributeDto] },
    })

    const attribute = await refetchEntity(
        'attribute',
        result[0].id,
        req.scope,
        req.queryConfig?.fields ?? []
    )

    res.status(201).json({ attribute })
}
```

## File: src/api/admin/plugin/attributes/validators.ts
```typescript
// src/api/admin/plugin/attributes/validators.ts
import { createFindParams, createSelectParams } from '@medusajs/medusa/api/utils/validators'

import { z } from 'zod'

export type AdminCreateAttributeValueType = z.infer<typeof AdminCreateAttributeValue>
export const AdminCreateAttributeValue = z.object({
    value: z.string(),
    rank: z.number(),
    metadata: z.record(z.unknown()).nullish().transform(val => val === null ? undefined : val),
})

export type AdminUpdateAttributeValueType = z.infer<typeof AdminUpdateAttributeValue>
export const AdminUpdateAttributeValue = z.object({
    id: z.string().optional(),
    value: z.string().optional(),
    rank: z.number().optional(),
    metadata: z.record(z.unknown()).nullish().transform(val => val === null ? undefined : val),
})

export type AdminGetAttributeValueParamsType = z.infer<typeof AdminGetAttributeValueParams>
export const AdminGetAttributeValueParams = createSelectParams()

export type AdminGetAttributeValuesParamsType = z.infer<typeof AdminGetAttributeValueParams>
export const AdminGetAttributeValuesParams = createFindParams()

export type AdminCreateAttributeType = z.infer<typeof AdminCreateAttribute>
export const AdminCreateAttribute = z.object({
    name: z.string(),
    description: z.string().optional(),
    is_filterable: z.boolean().default(true),
    handle: z.string().optional(),
    metadata: z.record(z.unknown()).nullish().transform(val => val === null ? undefined : val),
    possible_values: z.array(AdminCreateAttributeValue).optional(),
    product_category_ids: z.array(z.string()).optional()
})

export type AdminGetAttributeParamsType = z.infer<typeof AdminGetAttributeParams>
export const AdminGetAttributeParams = createSelectParams()

export type AdminGetAttributesParamsType = z.infer<typeof AdminGetAttributesParams>
export const AdminGetAttributesParams = createFindParams({
    offset: 0,
    limit: 50,
})

export type AdminUpdateAttributeType = z.infer<typeof AdminUpdateAttribute>
export const AdminUpdateAttribute = z.object({
    name: z.string().optional(),
    description: z.string().optional(),
    is_filterable: z.boolean().optional(),
    handle: z.string().nullish().transform(val => val === null ? undefined : val),
    metadata: z.record(z.unknown()).nullish().transform(val => val === null ? undefined : val),
    possible_values: z.array(AdminUpdateAttributeValue).optional(),
    // This field is accepted in the API but handled via links, not as a direct DB field
    product_category_ids: z.array(z.string()).optional(),
}).strict()
```

## File: src/api/admin/plugin/route.ts
```typescript
import { MedusaRequest, MedusaResponse } from "@medusajs/framework/http";

export async function GET(
  req: MedusaRequest,
  res: MedusaResponse
) {
  res.sendStatus(200);
}
```

## File: src/api/admin/products/[id]/attributes/[valueId]/route.ts
```typescript
import { MedusaRequest, MedusaResponse } from "@medusajs/framework"
import { deleteAttributeValueWorkflow } from "../../../../../../workflows/attribute-value/workflow"
import { ContainerRegistrationKeys, MedusaError, MedusaErrorTypes } from "@medusajs/framework/utils"
import attributeValueProduct from "../../../../../../links/attribute-value-product"

export const DELETE = async (req: MedusaRequest, res: MedusaResponse) => {
  const { id: productId, valueId } = req.params
  const query = req.scope.resolve(ContainerRegistrationKeys.QUERY)

  try {
    // Verify the attribute value exists and belongs to this product
    const { data: attributeValueLinks } = await query.graph({
      entity: attributeValueProduct.entryPoint,
      fields: ['attribute_value_id', 'product_id'],
      filters: {
        attribute_value_id: valueId,
        product_id: productId
      }
    })

    if (!attributeValueLinks.length) {
      throw new MedusaError(
        MedusaErrorTypes.NOT_FOUND,
        `Attribute value ${valueId} not found for product ${productId}`
      )
    }

    // Delete the attribute value and its links
    await deleteAttributeValueWorkflow(req.scope).run({
      input: [valueId]
    })

    return res.status(200).json({
      message: "Attribute value removed from product successfully",
      deleted: true,
      id: valueId,
      product_id: productId
    })
  } catch (error) {
    console.error('Error removing attribute from product:', error)

    if (error instanceof MedusaError) {
      return res.status(error.type === 'not_found' ? 404 : 400).json({
        error: error.message
      })
    }

    return res.status(500).json({
      error: "Failed to remove attribute from product",
      details: error.message
    })
  }
}

export const GET = async (req: MedusaRequest, res: MedusaResponse) => {
  const { id: productId, valueId } = req.params
  const query = req.scope.resolve(ContainerRegistrationKeys.QUERY)

  try {
    const { data: [attributeValueLink] } = await query.graph({
      entity: attributeValueProduct.entryPoint,
      fields: [
        "attribute_value.id",
        "attribute_value.value",
        "attribute_value.attribute.id",
        "attribute_value.attribute.name",
        "attribute_value.attribute.description",
        "attribute_value.attribute.handle",
        "attribute_value.attribute.is_variant_defining",
        "attribute_value.attribute.is_filterable",
        "attribute_value.attribute.possible_values"
      ],
      filters: {
        attribute_value_id: valueId,
        product_id: productId
      }
    })

    if (!attributeValueLink) {
      throw new MedusaError(
        MedusaErrorTypes.NOT_FOUND,
        `Attribute value ${valueId} not found for product ${productId}`
      )
    }

    const formattedAttributeValue = {
      id: attributeValueLink.attribute_value.id,
      value: attributeValueLink.attribute_value.value,
      attribute: {
        id: attributeValueLink.attribute_value.attribute.id,
        name: attributeValueLink.attribute_value.attribute.name,
        description: attributeValueLink.attribute_value.attribute.description,
        handle: attributeValueLink.attribute_value.attribute.handle,
        is_variant_defining: attributeValueLink.attribute_value.attribute.is_variant_defining,
        is_filterable: attributeValueLink.attribute_value.attribute.is_filterable,
        possible_values: attributeValueLink.attribute_value.attribute.possible_values || []
      }
    }

    return res.status(200).json({
      product_id: productId,
      attribute_value: formattedAttributeValue
    })
  } catch (error) {
    console.error('Error fetching product attribute:', error)

    if (error instanceof MedusaError) {
      return res.status(error.type === 'not_found' ? 404 : 400).json({
        error: error.message
      })
    }

    return res.status(500).json({
      error: "Failed to fetch product attribute",
      details: error.message
    })
  }
}
```

## File: src/api/admin/products/[id]/attributes/middlewares.ts
```typescript
import { MiddlewareRoute, validateAndTransformBody } from "@medusajs/framework"
import { z } from "zod"

const CreateProductAttributeSchema = z.object({
  attribute_id: z.string().min(1, "Attribute ID is required"),
  value: z.string().min(1, "Attribute value is required"),
})

export const productAttributesMiddlewares: MiddlewareRoute[] = [
  {
    method: ['POST'],
    matcher: '/admin/products/:id/attributes',
    middlewares: [
      validateAndTransformBody(CreateProductAttributeSchema)
    ]
  }
]
```

## File: src/api/admin/products/[id]/attributes/route.ts
```typescript
import { MedusaRequest, MedusaResponse } from "@medusajs/framework"
import { ContainerRegistrationKeys } from "@medusajs/framework/utils"
import { createAttributeValueWorkflow } from "../../../../../workflows/attribute-value/workflow"
import attributeValueProduct from "../../../../../links/attribute-value-product"

interface CreateProductAttributeBody {
  attribute_id: string
  value: string
}

export const POST = async (
  req: MedusaRequest<CreateProductAttributeBody>,
  res: MedusaResponse
) => {
  const productId = req.params.id
  const { attribute_id, value } = req.validatedBody

  try {
    const { result } = await createAttributeValueWorkflow(req.scope).run({
      input: {
        attribute_id,
        value,
        product_id: productId,
      }
    })

    return res.status(201).json({
      attribute_value: result,
      message: "Attribute successfully assigned to product"
    })
  } catch (error) {
    console.error('Error creating product attribute:', error)
    return res.status(400).json({
      error: "Failed to assign attribute to product",
      details: error.message
    })
  }
}

export const GET = async (req: MedusaRequest, res: MedusaResponse) => {
  const productId = req.params.id
  const query = req.scope.resolve(ContainerRegistrationKeys.QUERY)

  try {
    // Query the link entity to get attribute values for this product
    const { data: productAttributeLinks } = await query.graph({
      entity: attributeValueProduct.entryPoint,
      fields: [
        "attribute_value_id",
        "product_id",
        "attribute_value.id",
        "attribute_value.value",
        "attribute_value.attribute.id",
        "attribute_value.attribute.name",
        "attribute_value.attribute.description",
        "attribute_value.attribute.handle",
        "attribute_value.attribute.is_variant_defining",
        "attribute_value.attribute.is_filterable",
        "attribute_value.attribute.possible_values"
      ],
      filters: {
        product_id: productId
      }
    })

    const formattedAttributeValues = productAttributeLinks.map(link => ({
      id: link.attribute_value.id,
      value: link.attribute_value.value,
      attribute: {
        id: link.attribute_value.attribute.id,
        name: link.attribute_value.attribute.name,
        description: link.attribute_value.attribute.description,
        handle: link.attribute_value.attribute.handle,
        is_variant_defining: link.attribute_value.attribute.is_variant_defining,
        is_filterable: link.attribute_value.attribute.is_filterable,
        possible_values: link.attribute_value.attribute.possible_values || []
      }
    }))

    return res.status(200).json({
      product_id: productId,
      attribute_values: formattedAttributeValues,
      count: formattedAttributeValues.length
    })
  } catch (error) {
    console.error('Error fetching product attributes:', error)
    return res.status(500).json({
      error: "Failed to fetch product attributes",
      details: error.message
    })
  }
}
```

## File: src/api/admin/products/middlewares.ts
```typescript
import { MiddlewareRoute } from "@medusajs/framework"
import { productAttributesMiddlewares } from "./[id]/attributes/middlewares"

export const adminProductsMiddlewares: MiddlewareRoute[] = [
  ...productAttributesMiddlewares,
]
```

## File: src/api/admin/middlewares.ts
```typescript
import { MiddlewareRoute } from "@medusajs/framework";
import { adminAttributeRoutesMiddlewares } from "./plugin/attributes/middlewares";
import { adminAttributeSetMiddlewares } from "./plugin/attribute-set/middlewares";
import { adminProductsMiddlewares } from "./products/middlewares";

export const adminRoutesMiddlewares: MiddlewareRoute[] = [
    ...adminAttributeRoutesMiddlewares,
    ...adminAttributeSetMiddlewares,
    ...adminProductsMiddlewares,
]
```

## File: src/api/store/plugin/attributes/filters/middlewares.ts
```typescript
import { MiddlewareRoute, validateAndTransformQuery, authenticate } from "@medusajs/framework"
import { createFindParams } from "@medusajs/medusa/api/utils/validators"
import { z } from "zod"

const StoreGetAttributeFiltersParams = createFindParams().merge(
  z.object({
    category_id: z.string().optional(),
    include_counts: z.boolean().default(true).optional(),
  })
)

export const storeAttributeFiltersMiddlewares: MiddlewareRoute[] = [
  {
    method: ['GET'],
    matcher: '/store/plugin/attributes/filters',
    middlewares: [
      authenticate("customer", ["session", "bearer"], {
        allowUnauthenticated: true,
      }),
      validateAndTransformQuery(StoreGetAttributeFiltersParams, {
        defaults: ['id', 'name', 'handle', '*possible_values'],
        isList: true,
        defaultLimit: 50,
      })
    ]
  }
]
```

## File: src/api/store/plugin/attributes/products/[id]/middlewares.ts
```typescript
import { MiddlewareRoute, validateAndTransformQuery, authenticate } from "@medusajs/framework"
import { StoreGetProductsParams } from "@medusajs/medusa/api/store/products/validators"
import * as QueryConfig from "../query-config"


export const storeProductAttributesMiddlewares: MiddlewareRoute[] = [
  {
    method: ['GET'],

    matcher: '/store/plugin/attributes/products/:id',
    middlewares: [

      authenticate("customer", ["session", "bearer"], {
        allowUnauthenticated: true,
      }),

      validateAndTransformQuery(
        StoreGetProductsParams,
        QueryConfig.retrieveProductQueryConfig
      )
    ]
  }
]
```

## File: src/api/store/plugin/attributes/products/middlewares.ts
```typescript
import { applyDefaultFilters, authenticate, clearFiltersByKey, featureFlagRouter, maybeApplyLinkFilter, MiddlewareRoute, validateAndTransformQuery } from "@medusajs/framework";
import { ProductStatus, isPresent } from "@medusajs/framework/utils";
import { StoreGetProductsParams } from "@medusajs/medusa/api/store/products/validators";
import { filterByValidSalesChannels, normalizeDataForContext, setPricingContext, setTaxContext } from "@medusajs/medusa/api/utils/middlewares/index";
import IndexEngineFeatureFlag from "@medusajs/medusa/loaders/feature-flags/index-engine";
import * as OriginalQueryConfig from "@medusajs/medusa/api/store/products/query-config"
import { ExtendedStoreGetProductsParams } from "./validators";
import attributeValueProduct from "../../../../../links/attribute-value-product";

export const storeAttributesProductsMiddlewares: MiddlewareRoute[] = [
    {
        method: ["GET"],
        matcher: "/store/plugin/attributes/products",
        middlewares: [
          authenticate("customer", ["session", "bearer"], {
            allowUnauthenticated: true,
          }),
          validateAndTransformQuery(
            ExtendedStoreGetProductsParams,
            OriginalQueryConfig.listProductQueryConfig
          ),
          filterByValidSalesChannels(),
          (req, res, next) => {
            if (featureFlagRouter.isFeatureEnabled(IndexEngineFeatureFlag.key)) {
              return next()
            }
    
            return maybeApplyLinkFilter({
              entryPoint: "product_sales_channel",
              resourceId: "product_id",
              filterableField: "sales_channel_id",
            })(req, res, next)
          },
          applyDefaultFilters({
            status: ProductStatus.PUBLISHED,
            // TODO: the type here seems off and the implementation does not take into account $and and $or possible filters. Might be worth re working (original type used here was StoreGetProductsParamsType)
            categories: (filters: any, fields: string[]) => {
              const categoryIds = filters.category_id
              delete filters.category_id
    
              if (!isPresent(categoryIds)) {
                return
              }
    
              return { id: categoryIds, is_internal: false, is_active: true }
            },
          }),
          maybeApplyLinkFilter({
            entryPoint: attributeValueProduct.entryPoint,
            filterableField: 'attribute_value_id',
            resourceId: 'product_id'
          }),
          normalizeDataForContext(),
          setPricingContext(),
          setTaxContext(),
          clearFiltersByKey(["region_id", "country_code", "province", "cart_id"]),
        ],
      },
]
```

## File: src/api/store/plugin/attributes/products/query-config.ts
```typescript
import { defaultStoreProductFields } from "@medusajs/medusa/api/store/products/query-config";

const defaultExtendedStoreProductFields = [
    '*attribute_values',
]

export const retrieveProductQueryConfig = {
    defaults: [
        ...defaultStoreProductFields,
        ...defaultExtendedStoreProductFields
    ],
    isList: false,
} 

export const listProductQueryConfig = {
    ...retrieveProductQueryConfig,
    isList: true,
    defaultLimit: 50,
}
```

## File: src/api/store/plugin/attributes/products/route.ts
```typescript
// TODO: This is messy, but since Medusa doesn't allow to extend Core GET routes
// params validators, the only way i see to query core routes with linked
// custom modules entities, is to recreate route (in a custom one) middleware and
// apply the custom params validator

import { MedusaResponse } from "@medusajs/framework";
import { HttpTypes } from "@medusajs/framework/types";
import { isPresent, ContainerRegistrationKeys, remoteQueryObjectFromString } from "@medusajs/framework/utils";
import { RequestWithContext, wrapProductsWithTaxPrices } from "@medusajs/medusa/api/store/products/helpers";
import { wrapVariantsWithInventoryQuantityForSalesChannel } from "@medusajs/medusa/api/utils/middlewares/index";
import { ExtendedStoreGetProductsParamsType } from "./validators";

export const GET = async (
  req: RequestWithContext<ExtendedStoreGetProductsParamsType>,
  res: MedusaResponse<HttpTypes.StoreProductListResponse>
) => {
  return await getProducts(req, res);
};

async function getProducts(
  req: RequestWithContext<HttpTypes.StoreProductListParams>,
  res: MedusaResponse<HttpTypes.StoreProductListResponse>
) {
  const remoteQuery = req.scope.resolve(ContainerRegistrationKeys.REMOTE_QUERY);
  const context: object = {};
  const withInventoryQuantity = req.queryConfig.fields.some((field) =>
    field.includes("variants.inventory_quantity")
  );

  if (withInventoryQuantity) {
    req.queryConfig.fields = req.queryConfig.fields.filter(
      (field) => !field.includes("variants.inventory_quantity")
    );
  }

  if (isPresent(req.pricingContext)) {
    context["variants.calculated_price"] = {
      context: req.pricingContext,
    };
  }

  const queryObject = remoteQueryObjectFromString({
    entryPoint: "product",
    variables: {
      filters: req.filterableFields,
      ...req.queryConfig.pagination,
      ...context,
    },
    fields: req.queryConfig.fields,
  });

  const { rows: products, metadata } = await remoteQuery(queryObject);

  if (withInventoryQuantity) {
    await wrapVariantsWithInventoryQuantityForSalesChannel(
      req,
      products.map((product) => product.variants).flat(1)
    );
  }

  await wrapProductsWithTaxPrices(req, products);
  res.json({
    products,
    count: metadata.count,
    offset: metadata.skip,
    limit: metadata.take,
  });
}
```

## File: src/api/store/plugin/attributes/products/validators.ts
```typescript
import {
  StoreGetProductsParamsFields,
  StoreGetProductVariantsParamsFields,
} from "@medusajs/medusa/api/store/products/validators";
import {
  applyAndAndOrOperators,
  recursivelyNormalizeSchema,
} from "@medusajs/medusa/api/utils/common-validators/common";
import {
  StoreGetProductParamsDirectFields,
  transformProductParams,
} from "@medusajs/medusa/api/utils/common-validators/index";
import { createFindParams } from "@medusajs/medusa/api/utils/validators";
import { z } from "zod";

//TODO: this is messy, but since Medusa exports an effect, the only way (AFAIK) to extend the schema
// and to keep the logic of the effects at the same time, the only way is to recreate
// the Medusa zod object, merge with the custom one and apply the effect
const OriginalStoreGetProductsParamsWithoutEffect = createFindParams({
  offset: 0,
  limit: 50,
})
  .merge(StoreGetProductsParamsFields)
  .merge(
    z
      .object({
        variants: z
          .object({
            options: z
              .object({
                value: z.string().optional(),
                option_id: z.string().optional(),
              })
              .optional(),
          })
          .merge(applyAndAndOrOperators(StoreGetProductVariantsParamsFields))
          .optional(),
      })
      .merge(applyAndAndOrOperators(StoreGetProductParamsDirectFields))
      .strict()
  );

const CustomStoreGetProductsParams = z.object({
  attribute_value_id: z.array(z.string()).optional(),
});

export type ExtendedStoreGetProductsParamsType = z.infer<
  typeof OriginalStoreGetProductsParamsWithoutEffect
>;
export const ExtendedStoreGetProductsParams =
  OriginalStoreGetProductsParamsWithoutEffect.merge(
    CustomStoreGetProductsParams
  )
    // .merge(applyAndAndOrOperators(CustomStoreGetProductsParams))
    .transform(recursivelyNormalizeSchema(transformProductParams));
```

## File: src/api/store/plugin/attributes/middlewares.ts
```typescript
import {
  clearFiltersByKey,
  maybeApplyLinkFilter,
  MiddlewareRoute,
  validateAndTransformQuery,
} from "@medusajs/framework";
import { storeAttributesBaseRoute } from "../../../utils/constants";
import { StoreGetAttributesParams } from "./validators";
import * as QueryConfig from "./query-config";
import { storeAttributesProductsMiddlewares } from "./products/middlewares";
import attributeProductCategory from "../../../../links/attribute-product-category";
import { addGlobalAttributesIfNecessary } from "../../../utils/middlewares";

export const storeAttributesMiddlewaresRoute: MiddlewareRoute[] = [
  {
    methods: ["GET"],
    matcher: storeAttributesBaseRoute,
    middlewares: [
      validateAndTransformQuery(
        StoreGetAttributesParams,
        QueryConfig.storeListAttributesQueryConfig
      ),
      maybeApplyLinkFilter({
        entryPoint: attributeProductCategory.entryPoint,
        resourceId: 'attribute_id',
        filterableField: 'product_category_id'
      }),
      addGlobalAttributesIfNecessary(),
      clearFiltersByKey(['include_globals']),
    ],
  },
  ...storeAttributesProductsMiddlewares,
];
```

## File: src/api/store/plugin/attributes/query-config.ts
```typescript
export const storeDefaultAttributeFields = [
    'id',
    'name',
    'description',
    'handle',
    'metadata',
    '*possible_values',
]

export const retrieveStoreAttributesQueryConfig = {
    defaults: storeDefaultAttributeFields,
    isList: false,
}

export const storeListAttributesQueryConfig = {
    ...retrieveStoreAttributesQueryConfig,
    isList: true,
    defaultLimit: 50,
}
```

## File: src/api/store/plugin/attributes/route.ts
```typescript
import { MedusaRequest, MedusaResponse } from "@medusajs/framework";
import { ContainerRegistrationKeys } from "@medusajs/framework/utils";
import { StoreGetAttributesParamsType } from "./validators";

export const GET = async (req: MedusaRequest<StoreGetAttributesParamsType>, res: MedusaResponse) => {
    const query = req.scope.resolve(ContainerRegistrationKeys.QUERY)
    const { data: attributes, metadata } = await query.graph({
        entity: 'attribute',
        ...req.queryConfig,
        filters: req.filterableFields,
    })
    return res.status(200).json({ attributes, count: metadata?.count, limit: metadata?.take, offset: metadata?.skip })
}
```

## File: src/api/store/plugin/attributes/validators.ts
```typescript
import { createFindParams } from "@medusajs/medusa/api/utils/validators";
import { z } from "zod";
import { GetAttributesParams, StoreGetAttributeParamsDirectFields } from "../../../utils/common-validators";
import { applyAndAndOrOperators } from "@medusajs/medusa/api/utils/common-validators/common";

export const StoreGetAttributesParamsFields = GetAttributesParams.strict();

export type StoreGetAttributesParamsType = z.infer<typeof StoreGetAttributesParams>
export const StoreGetAttributesParams = createFindParams({
  offset: 0,
  limit: 50,
})
  .merge(StoreGetAttributesParamsFields)
  .merge(applyAndAndOrOperators(StoreGetAttributeParamsDirectFields).strict());
```

## File: src/api/store/plugin/route.ts
```typescript
import { MedusaRequest, MedusaResponse } from "@medusajs/framework/http";

export async function GET(
  req: MedusaRequest,
  res: MedusaResponse
) {
  res.sendStatus(200);
}
```

## File: src/api/store/middlewares.ts
```typescript
import { MiddlewareRoute } from "@medusajs/framework";
import { storeAttributesMiddlewaresRoute } from "./plugin/attributes/middlewares";

export const storeMiddlewaresRoutes: MiddlewareRoute[] = [
    ...storeAttributesMiddlewaresRoute
]
```

## File: src/api/utils/common-validators.ts
```typescript
import { createOperatorMap } from '@medusajs/medusa/api/utils/validators'
import { z } from 'zod'

export const StoreGetAttributeParamsDirectFields = z.object({
    id: z.union([z.string(), z.array(z.string())]).optional(),
    name: z.union([z.string(), z.array(z.string())]).optional(),
    description: z.union([z.string(), z.array(z.string())]).optional(),
    handle: z.union([z.string(), z.array(z.string())]).optional(),
    created_at: createOperatorMap().optional(),
    updated_at: createOperatorMap().optional(),
    deleted_at: createOperatorMap().optional(),
})

export const GetAttributesParams = z
    .object({
        product_category_id: z.union([z.string(), z.array(z.string())]).optional(),
        include_globals: z.preprocess(
            (val) => {
                return val === 'true'
            },
            z.boolean().default(true),
        )
    })
    .merge(StoreGetAttributeParamsDirectFields)
```

## File: src/api/utils/constants.ts
```typescript
export const adminAttributesRoutePath = '/admin/plugin/attributes'
export const storeAttributesBaseRoute = '/store/plugin/attributes'
```

## File: src/api/utils/middlewares.ts
```typescript
import { MedusaNextFunction, MedusaRequest, MedusaResponse } from "@medusajs/framework";
import { arrayDifference, ContainerRegistrationKeys, deduplicate } from "@medusajs/framework/utils";
import attributeProductCategory from "../../links/attribute-product-category";

export const addGlobalAttributesIfNecessary = () => async (req: MedusaRequest, res: MedusaResponse, next: MedusaNextFunction) => {
    const filterableFields = req.filterableFields || {}
    const shouldIncludeGlobals = filterableFields.include_globals

    if(!shouldIncludeGlobals) {
        return next()
    }

    const query = req.scope.resolve(ContainerRegistrationKeys.QUERY)
    const { data: allAttributes } = await query.graph({
        entity: 'attribute',
        fields: ['id']
    })
    const { data: attributesWithCategories } = await query.graph({
        entity: attributeProductCategory.entryPoint,
        fields: ['attribute_id']
    })

    const alreadyFilteredAttributeIds = (filterableFields.id || []) as string[]
    const allAttributesIds = allAttributes.map(attr => attr.id)
    const attributesWithCategoriesIds = deduplicate(attributesWithCategories.map(attrCat => attrCat.attribute_id))
    req.filterableFields.id = [
        ...alreadyFilteredAttributeIds,
        ...arrayDifference(allAttributesIds, attributesWithCategoriesIds)
    ]
    return next()
}
```

## File: src/api/middlewares.ts
```typescript
import { defineMiddlewares } from "@medusajs/framework";
import { adminRoutesMiddlewares } from "./admin/middlewares";
import { storeMiddlewaresRoutes } from "./store/middlewares";

export default defineMiddlewares({
    routes: [
        ...adminRoutesMiddlewares,
        ...storeMiddlewaresRoutes,
    ]
})
```

## File: src/jobs/README.md
```markdown
# Custom scheduled jobs

A scheduled job is a function executed at a specified interval of time in the background of your Medusa application.

A scheduled job is created in a TypeScript or JavaScript file under the `src/jobs` directory.

For example, create the file `src/jobs/hello-world.ts` with the following content:

```ts
import {
  MedusaContainer
} from "@medusajs/framework/types";

export default async function myCustomJob(container: MedusaContainer) {
  const productService = container.resolve("product")

  const products = await productService.listAndCountProducts();

  // Do something with the products
}

export const config = {
  name: "daily-product-report",
  schedule: "0 0 * * *", // Every day at midnight
};
```

A scheduled job file must export:

- The function to be executed whenever it’s time to run the scheduled job.
- A configuration object defining the job. It has three properties:
  - `name`: a unique name for the job.
  - `schedule`: a [cron expression](https://crontab.guru/).
  - `numberOfExecutions`: an optional integer, specifying how many times the job will execute before being removed

The `handler` is a function that accepts one parameter, `container`, which is a `MedusaContainer` instance used to resolve services.
```

## File: src/links/attribute-product-category.ts
```typescript
import { defineLink } from "@medusajs/framework/utils";
import AttributeModule from '../modules/attribute'
import ProductModule from "@medusajs/medusa/product";

export default defineLink(
    {
        linkable: AttributeModule.linkable.attribute,
        isList: true
    },
    {
        linkable: ProductModule.linkable.productCategory,
        isList: true
    }
)
```

## File: src/links/attribute-value-product.ts
```typescript
import { defineLink } from "@medusajs/framework/utils"
import AttributeModule from '../modules/attribute'
import ProductModule from "@medusajs/medusa/product"

export default defineLink(
    {
        linkable: AttributeModule.linkable.attributeValue,
        isList: true,
    },
    {
        linkable: ProductModule.linkable.product,
        isList: true,
    }
)
```

## File: src/links/README.md
```markdown
# Module Links

A module link forms an association between two data models of different modules, while maintaining module isolation.

Learn more about links in [this documentation](https://docs.medusajs.com/learn/fundamentals/module-links)

For example:

```ts
import BlogModule from "../modules/blog"
import ProductModule from "@medusajs/medusa/product"
import { defineLink } from "@medusajs/framework/utils"

export default defineLink(
  ProductModule.linkable.product,
  BlogModule.linkable.post
)
```

This defines a link between the Product Module's `product` data model and the Blog Module (custom module)'s `post` data model.

Then, in the Medusa application using this plugin, run the following command to sync the links to the database:

```bash
npx medusa db:migrate
```
```

## File: src/modules/attribute/events/index.ts
```typescript
export const AttributeWorkflowsEvents = {
    CREATED: 'attribute.created',
    UPDATED: 'attribute.updated',
}
```

## File: src/modules/attribute/models/attribute-possible-value.ts
```typescript
import Attribute from "./attribute";
import { model } from "@medusajs/framework/utils";

const AttributePossibleValue = model.define('attribute_possible_value', {
    id: model.id({ prefix: 'attrposval' }).primaryKey(),
    value: model.text(),
    rank: model.number(),
    metadata: model.json().nullable(),
    attribute: model.belongsTo(() => Attribute, {
        mappedBy: 'possible_values',
    })
}).indexes([
    {
        on: ['attribute_id', 'value'],
        name: 'UQ_attribute_id_value',
        unique: true,
    }
])

export default AttributePossibleValue
```

## File: src/modules/attribute/models/attribute-set.ts
```typescript
import Attribute from "./attribute"
import { model } from "@medusajs/framework/utils"

const AttributeSet = model.define('attribute_set', {
    id: model.id({ prefix: 'attrset' }).primaryKey(),
    name: model.text().index('IDX_ATTRIBUTE_SET_NAME').searchable(),
    description: model.text().nullable(),
    handle: model.text().unique(),
    metadata: model.json().nullable(),
    attributes: model.manyToMany(() => Attribute, {
        mappedBy: 'sets',
        pivotTable: 'attribute_set_attributes',
        join_column: 'attribute_set_id',
        inverseJoinColumn: 'attribute_id',
    }),
})

export default AttributeSet
```

## File: src/modules/attribute/models/attribute-value.ts
```typescript
import Attribute from "./attribute";
import { model } from "@medusajs/framework/utils";

const AttributeValue = model.define('attribute_value', {
    id: model.id({ prefix: 'attrval' }).primaryKey(),
    value: model.text(),
    metadata: model.json().nullable(),
    attribute: model.belongsTo(() => Attribute, {
        mappedBy: 'values',
    })
})

export default AttributeValue
```

## File: src/modules/attribute/models/attribute.ts
```typescript
import AttributePossibleValue from "./attribute-possible-value"
import AttributeSet from "./attribute-set"
import AttributeValue from "./attribute-value"
import { model } from "@medusajs/framework/utils"

const Attribute = model.define('attribute', {
    id: model.id({ prefix: 'attr' }).primaryKey(),
    name: model.text().index('IDX_ATTRIBUTE_NAME').searchable(),
    description: model.text().nullable(),
    is_filterable: model.boolean().default(true),
    handle: model.text().unique(),
    metadata: model.json().nullable(),
    possible_values: model.hasMany(() => AttributePossibleValue),
    values: model.hasMany(() => AttributeValue),
    sets: model.manyToMany(() => AttributeSet, { mappedBy: 'attributes' }),
}).cascades({
    delete: ['values']
})

export default Attribute
```

## File: src/modules/attribute/types/attribute/common.ts
```typescript
// src/modules/attribute/types/attribute/common.ts
import { AdminCreateAttributeType } from "../../../../api/admin/plugin/attributes/validators"

export type CreateAttributesWorkflowInput = {
    attributes: AdminCreateAttributeType[]
}

// Remove product_category_ids from the step input since it's handled via links
export type CreateAttributeStepInput = Omit<AdminCreateAttributeType, 'product_category_ids'>[]

/**
 * @interface
 *
 * The data to update the attribute.
 */
export interface UpdateAttributeDTO {
    /**
     * The id of the attribute to update.
     */
    id: string

    /**
     * The name of the attribute.
     */
    name?: string

    /**
     * The description of the attribute.
     */
    description?: string

    /**
     * Whether the attribute can be used to filter products.
     */
    is_filterable?: boolean

    /**
     * The handle of the attribute. The handle can be used to create slug URL paths.
     * If not supplied, the value of the `handle` attribute of the attribute is set to the slug version of the `name` property.
     */
    handle?: string

    /**
     * Holds custom data in key-value pairs.
     */
    metadata?: Record<string, unknown>

    /**
     * The associated possible values to update/create
     */
    possible_values?: UpsertAttributeValueDTO[]

    /**
     * The associated product categories (handled via links, not direct DB relationship)
     * This field is accepted in API but processed separately from the core attribute data
     */
    product_category_ids?: string[]
}

/**
 * @interface
 *
 * The data to update or create an attribute value.
 */
export interface UpsertAttributeValueDTO {
    /**
     * The id of the attribute value to update.
     */
    id?: string
    /**
     * The value of the attribute value.
     */
    value?: string
    /**
     * The rank of the attribute value. Useful to visually order it on dropdowns.
     */
    rank?: number
    /**
     * Holds custom data in key-value pairs.
     */
    metadata?: Record<string, unknown>
    /**
     * The id of the associated attribute.
     */
    attribute_id?: string
}

/**
 * @interface
 *
 * The data to update an attribute value.
 */
export interface UpdateAttributeValueDTO {
    /**
     * The id of the attribute value to update.
     */
    id: string

    /**
     * The value of the attribute value.
     */
    value?: string

    /**
     * The rank of the attribute value. Useful to visually order it on dropdowns.
     */
    rank?: number

    /**
     * Holds custom data in key-value pairs.
     */
    metadata?: Record<string, unknown>

    /**
     * The id of the associated attribute.
     */
    attribute_id?: string
}
```

## File: src/modules/attribute/types/attribute/index.ts
```typescript
export * from './common'
```

## File: src/modules/attribute/types/attribute-set/index.ts
```typescript
export * from './mutations'
```

## File: src/modules/attribute/types/attribute-set/mutations.ts
```typescript
export type CreateAttributeSetDTO = {
    name: string
    handle?: string
    description?: string
    metadata?: Record<string, unknown> | null
    attributes?: string[]
}
```

## File: src/modules/attribute/types/attribute-value/index.ts
```typescript
export * from './mutations'
```

## File: src/modules/attribute/types/attribute-value/mutations.ts
```typescript
export type CreateProductAttributeValueDTO = {
    attribute_id: string;
    product_id: string;
    value: string;
}
```

## File: src/modules/attribute/types/index.ts
```typescript
export * from './attribute'
export * from './attribute-set'
export * from './attribute-value'
```

## File: src/modules/attribute/index.ts
```typescript
import AttributeModuleService from "./service"
import { Module } from "@medusajs/framework/utils"

export const ATTRIBUTE_MODULE = 'attribute'

export default Module(ATTRIBUTE_MODULE, {
    service: AttributeModuleService,
})
```

## File: src/modules/attribute/service.ts
```typescript
// src/modules/attribute/service.ts
import {
    arrayDifference,
  InjectManager,
  InjectTransactionManager,
  MedusaContext,
  MedusaService,
} from "@medusajs/framework/utils";
import Attribute from "./models/attribute";
import { Context, DAL, InferTypeOf } from "@medusajs/framework/types";
import { EntityManager } from "@mikro-orm/knex";
import {
  CreateAttributeValueDTO,
  UpdateAttributeDTO,
  UpsertAttributeValueDTO,
  UpdateAttributeValueDTO,
} from "../../types/attribute";
import AttributeValue from "./models/attribute-value";
import AttributeSet from "./models/attribute-set";
import AttributePossibleValue from "./models/attribute-possible-value";

type Attribute = InferTypeOf<typeof Attribute>
type AttributePossibleValue = InferTypeOf<typeof AttributePossibleValue>

type InjectedDependencies = {
  attributeRepository: DAL.RepositoryService<Attribute>;
  attributePossibleValueRepository: DAL.RepositoryService<AttributePossibleValue>;
};

class AttributeModuleService extends MedusaService({
  Attribute,
  AttributeValue,
  AttributeSet,
  AttributePossibleValue,
}) {
  protected attributeRepository_: DAL.RepositoryService<Attribute>;
  protected attributePossibleValueRepository_: DAL.RepositoryService<AttributePossibleValue>;

  constructor({
    attributeRepository,
    attributePossibleValueRepository,
  }: InjectedDependencies) {
    super(...arguments);
    this.attributeRepository_ = attributeRepository;
    this.attributePossibleValueRepository_ = attributePossibleValueRepository;
  }

  /**
   * Update attribute with upsert or replace possible values
   * This method handles only the core attribute data and possible values
   * Category relationships are handled separately via links
   */
  @InjectManager()
  async updateAttributeWithUpsertOrReplacePossibleValues(
    input: Omit<UpdateAttributeDTO, 'product_category_ids'> | Omit<UpdateAttributeDTO, 'product_category_ids'>[],
    @MedusaContext() sharedContext?: Context<EntityManager>
  ) {
    const normalizedInput = Array.isArray(input) ? input : [input];

    return this.updateAttributeWithUpsertOrReplacePossibleValues_(
      normalizedInput,
      sharedContext
    );
  }

  @InjectTransactionManager()
  protected async updateAttributeWithUpsertOrReplacePossibleValues_(
    input: Omit<UpdateAttributeDTO, 'product_category_ids'>[],
    @MedusaContext() sharedContext?: Context<EntityManager>
  ) {
    // Handle possible values if they exist
    const possibleValuesInput = input
      .filter(element => element.possible_values && element.possible_values.length > 0)
      .flatMap(element => element.possible_values!);

    let upsertedValues: any[] = [];
    if (possibleValuesInput.length > 0) {
      // Upsert possible values
      upsertedValues = await this.attributePossibleValueRepository_.upsert(
        possibleValuesInput,
        sharedContext
      );
    }

    // Prepare attributes input without possible_values for direct update
    const attributesInput = input.map(toUpdate => {
      const { possible_values, ...attribute } = toUpdate;

      // Only add possible_values if they were provided and upserted
      const attributeData: any = { ...attribute };

      if (possible_values && possible_values.length > 0) {
        attributeData.possible_values = upsertedValues
          .filter(val => val.attribute_id === attribute.id)
          .map(upserted => ({ id: upserted.id }));
      }

      return attributeData;
    });

    return this.attributeRepository_.upsertWithReplace(
      attributesInput,
      { relations: ['possible_values'] },
      sharedContext
    );
  }
}

export default AttributeModuleService;
```

## File: src/modules/README.md
```markdown
# Custom Module

A module is a package of reusable functionalities. It can be integrated into your Medusa application without affecting the overall system. You can create a module as part of a plugin.

Learn more about modules in [this documentation](https://docs.medusajs.com/learn/fundamentals/modules).

To create a module:

## 1. Create a Data Model

A data model represents a table in the database. You create a data model in a TypeScript or JavaScript file under the `models` directory of a module.

For example, create the file `src/modules/blog/models/post.ts` with the following content:

```ts
import { model } from "@medusajs/framework/utils"

const Post = model.define("post", {
  id: model.id().primaryKey(),
  title: model.text(),
})

export default Post
```

## 2. Create a Service

A module must define a service. A service is a TypeScript or JavaScript class holding methods related to a business logic or commerce functionality.

For example, create the file `src/modules/blog/service.ts` with the following content:

```ts
import { MedusaService } from "@medusajs/framework/utils"
import Post from "./models/post"

class BlogModuleService extends MedusaService({
  Post,
}){
}

export default BlogModuleService
```

## 3. Export Module Definition

A module must have an `index.ts` file in its root directory that exports its definition. The definition specifies the main service of the module.

For example, create the file `src/modules/blog/index.ts` with the following content:

```ts
import BlogModuleService from "./service"
import { Module } from "@medusajs/framework/utils"

export const BLOG_MODULE = "blog"

export default Module(BLOG_MODULE, {
  service: BlogModuleService,
})
```

## 4. Generate Migrations

To generate migrations for your module, run the following command in the plugin's directory:

```bash
npx medusa plugin:db:genreate
```

## Use Module

You can use the module in customizations within the plugin or within the Medusa application using this plugin. When the plugin is added to a Medusa application, all its modules are registered as well.

For example, to use the module in an API route:

```ts
import { MedusaRequest, MedusaResponse } from "@medusajs/framework"
import BlogModuleService from "../../../modules/blog/service"
import { BLOG_MODULE } from "../../../modules/blog"

export async function GET(
  req: MedusaRequest,
  res: MedusaResponse
): Promise<void> {
  const blogModuleService: BlogModuleService = req.scope.resolve(
    BLOG_MODULE
  )

  const posts = await blogModuleService.listPosts()

  res.json({
    posts
  })
}
```

## Module Options

When you register the plugin in the Medusa application, it can accept options. These options are passed to the modules within the plugin:

```ts
import { defineConfig } from "@medusajs/framework/utils"

module.exports = defineConfig({
  // ...
  plugins: [
    {
      resolve: "@myorg/plugin-name",
      options: {
        apiKey: process.env.API_KEY,
      },
    },
  ],
})
```

Learn more about module options in [this documentation](https://docs.medusajs.com/learn/fundamentals/modules/options).
```

## File: src/providers/README.md
```markdown
## Module Providers

You can create module providers, such as Notification or File Module Providers under a sub-directory of this directory. For example, `src/providers/my-notification`.

Then, you register them in the Medusa application as `plugin-name/providers/my-notification`:

```ts
module.exports = defineConfig({
  // ...
  modules: [
    {
      resolve: "@medusajs/medusa/notification",
      options: {
        providers: [
          {
            resolve: "@myorg/plugin-name/providers/my-notification",
            id: "my-notification",
            options: {
              channels: ["email"],
              // provider options...
            },
          },
        ],
      },
    },
  ],
})
```

Learn more in [this documentation](https://docs.medusajs.com/learn/fundamentals/plugins/create).
```

## File: src/subscribers/README.md
```markdown
# Custom subscribers

Subscribers handle events emitted in the Medusa application.

The subscriber is created in a TypeScript or JavaScript file under the `src/subscribers` directory.

For example, create the file `src/subscribers/product-created.ts` with the following content:

```ts
import {
  type SubscriberConfig,
} from "@medusajs/framework"

// subscriber function
export default async function productCreateHandler() {
  console.log("A product was created")
}

// subscriber config
export const config: SubscriberConfig = {
  event: "product.created",
}
```

A subscriber file must export:

- The subscriber function that is an asynchronous function executed whenever the associated event is triggered.
- A configuration object defining the event this subscriber is listening to.

## Subscriber Parameters

A subscriber receives an object having the following properties:

- `event`: An object holding the event's details. It has a `data` property, which is the event's data payload.
- `container`: The Medusa container. Use it to resolve modules' main services and other registered resources.

```ts
import type {
  SubscriberArgs,
  SubscriberConfig,
} from "@medusajs/framework"

export default async function productCreateHandler({
  event: { data },
  container,
}: SubscriberArgs<{ id: string }>) {
  const productId = data.id

  const productModuleService = container.resolve("product")

  const product = await productModuleService.retrieveProduct(productId)

  console.log(`The product ${product.title} was created`)
}

export const config: SubscriberConfig = {
  event: "product.created",
}
```
```

## File: src/types/attribute/http/attribute/index.ts
```typescript
export * from './admin'
```

## File: src/types/attribute/http/index.ts
```typescript
export * from './attribute'
```

## File: src/types/attribute/common.ts
```typescript
/**
 * @interface
 * 
 * The data to update the attribute.
 */
export interface UpdateAttributeDTO {
    /**
     * The id of the attribute to update.
     */
    id: string
    
    /**
     * The name of the attribute.
     */
    name?: string

    /**
     * The description of the attribute.
     */
    description?: string

    /**
     * Whether the attribute should be used as a Blueprint for options
     * when creating them a product variant.
     */
    is_variant_defining?: boolean

    /**
     * Whether the attribute can be used to filter products.
     */
    is_filterable?: boolean

    /**
     * The handle of the attribute. The handle can be used to create slug URL paths.
     * If not supplied, the value of the `handle` attribute of the attribute is set to the slug version of the `name` property.
     */
    handle?: string

    /**
     * Holds custom data in key-value pairs.
     */
    metadata?: Record<string, unknown>

    /**
     * The associated attribute values to create or update. If "id" is not provided, it will try to update an existent attribute,
     * matching by "value", if not found, it will create a new one and "value" is required.
     */
    possible_values?: UpsertAttributeValueDTO[]

    /**
     * The associated product categories.
     */
    categories?: { id: string }[]
}

/**
 * @interface
 * 
 * The data to update or create an attribute value.
 */
export interface UpsertAttributeValueDTO {
    /**
     * The id of the attribute value to update.
     */
    id?: string

    /**
     * The value of the attribute value.
     */
    value?: string

    /**
     * The rank of the attribute value. Useful to visually order it on dropdowns.
     */
    rank?: number

    /**
     * Holds custom data in key-value pairs.
     */
    metadata?: Record<string, unknown>

    /**
     * The id of the associated attribute.
     */
    attribute_id?: string
}

/**
 * @interface
 * 
 * The data to create the attribute value.
 */
export interface CreateAttributeValueDTO {
    value: string
    rank: number
    attribute_id: string
    metadata?: Record<string, unknown>
}

/**
 * @interface
 * 
 * The data to update or create an attribute value.
 */
export interface UpsertAttributeValueDTO {
    /**
     * The id of the attribute value to update.
     */
    id?: string

    /**
     * The value of the attribute value.
     */
    value?: string

    /**
     * The rank of the attribute value. Useful to visually order it on dropdowns.
     */
    rank?: number

    /**
     * Holds custom data in key-value pairs.
     */
    metadata?: Record<string, unknown>

    /**
     * The id of the associated attribute.
     */
    attribute_id?: string
}

/**
 * @interface
 * 
 * The data to update an attribute value
 */
export interface UpdateAttributeValueDTO {
    /**
     * The id of the attribute value to update.
     */
    id: string

    /**
     * The value of the attribute value.
     */
    value?: string

    /**
     * The rank of the attribute value. Useful to visually order it on dropdowns.
     */
    rank?: number

    /**
     * Holds custom data in key-value pairs.
     */
    metadata?: Record<string, unknown>

    /**
     * The id of the associated attribute.
     */
    attribute_id?: string
}

export interface ProductAttributeValueDTO {
    /**
     * The value of the attribute value.
     */
    value: string;
     /**
     * The id of the associated attribute.
     */
    attribute_id: string;
}
```

## File: src/types/attribute/index.ts
```typescript
export * from './http'
export * from './common'
```

## File: src/utils/index.ts
```typescript
export * from './products-created-handler'
```

## File: src/utils/products-created-handler.ts
```typescript
import {
  MedusaContainer,
  ProductDTO,
} from "@medusajs/framework/types";

import { ProductAttributeValueDTO } from "../types/attribute";
import { createAttributeValueWorkflow } from "../workflows/attribute-value/workflow";
import { validateAttributeValuesToLink } from "./validate-attribute-values-to-link";

export const productsCreatedHookHandler = async ({
  products,
  additional_data,
  container,
}: {
  products: ProductDTO[];
  additional_data: Record<string, unknown> | undefined;
  container: MedusaContainer;
}) => {
  const attributeValues = (additional_data?.values ?? []) as ProductAttributeValueDTO[];
  const productIds = products.map((prod) => prod.id);

  if (!attributeValues.length) {
    return [];
  }

  await Promise.all(productIds.flatMap(prodId => attributeValues.map(async attrVal => {
    return createAttributeValueWorkflow(container).run({
      input: {
        attribute_id: attrVal.attribute_id,
        value: attrVal.value,
        product_id: prodId,
      }
    })
  })))
};
```

## File: src/utils/products-updated-handler.ts
```typescript
import { createAttributeValueWorkflow, deleteAttributeValueWorkflow } from "../workflows/attribute-value/workflow";

import { ContainerRegistrationKeys } from "@medusajs/framework/utils";
import { MedusaContainer } from "@medusajs/framework";
import { ProductAttributeValueDTO } from "../types/attribute";
import { ProductDTO } from "@medusajs/framework/types";
import attributeValueProduct from "../links/attribute-value-product";
import { validateAttributeValuesToLink } from "./validate-attribute-values-to-link";

export const productsUpdatedHookHandler = async ({
  products,
  additional_data,
  container,
}: {
  products: ProductDTO[];
  additional_data: Record<string, unknown> | undefined;
  container: MedusaContainer;
}) => {
  const query = container.resolve(ContainerRegistrationKeys.QUERY)
  
  const attributeValues = (additional_data?.values ?? []) as ProductAttributeValueDTO[];
  const productIds = products.map((prod) => prod.id);

  if (!attributeValues.length) {
    return [];
  }

  const updatedValueIds = (await Promise.all(productIds.map(async prodId => {
    const { data: productValues } = await query.graph({
      entity: attributeValueProduct.entryPoint,
      fields: ['attribute_value.id', 'attribute_value.value'],
      filters: {
        product_id: prodId
      }
    })

    return Promise.all(attributeValues.map(async attrVal => {
      const existentProductValue = productValues.find(prodVal => prodVal.attribute_value.value === attrVal.value)
      if (existentProductValue) {
        return existentProductValue.attribute_value.id as string
      }

      const { result } = await createAttributeValueWorkflow(container).run({
        input: {
          attribute_id: attrVal.attribute_id,
          value: attrVal.value,
          product_id: prodId,
        }
      })
      return result.id
    }))
  }))).flat()

  const { data } = await query.graph({
    entity: attributeValueProduct.entryPoint,
    fields: ['attribute_value_id'],
    filters: {
      attribute_value_id: {
        $nin: updatedValueIds
      },
      product_id: productIds
    }
  })

  if (!data.length) {
    return;
  }
  
  await deleteAttributeValueWorkflow(container).run({
    input: data.map(val => val.attribute_value_id)
  })
};
```

## File: src/utils/validate-attribute-values-to-link.ts
```typescript
import {
  ContainerRegistrationKeys,
  MedusaError,
  MedusaErrorTypes,
} from "@medusajs/framework/utils";
import { InferTypeOf, MedusaContainer, ProductCategoryDTO, ProductDTO } from "@medusajs/framework/types";

import Attribute from "../modules/attribute/models/attribute";
import { ProductAttributeValueDTO } from "../types/attribute";

export const validateAttributeValuesToLink = async ({
  attributeValues,
  products,
  container,
}: {
  attributeValues: ProductAttributeValueDTO[];
  products: ProductDTO[];
  container: MedusaContainer;
}) => {
  const query = container.resolve(ContainerRegistrationKeys.QUERY);

  const attributeMap = new Map<string, InferTypeOf<typeof Attribute> & { product_categories?: ProductCategoryDTO[] }>()

  for (const attrVal of attributeValues) {
    const id = attrVal.attribute_id

    if (!attributeMap.get(id)) {
      const { data: [attribute] } = await query.graph({
        entity: 'attribute',
        fields: ['product_categories.*', 'possible_values.*'],
        filters: {
          id: id
        }
      }) 
      
      attributeMap.set(id, attribute)
    }

    const allowedValues = attributeMap.get(id)?.possible_values?.map(posVal => posVal.value)

    if (allowedValues?.length && !allowedValues.includes(attrVal.value)) {
      throw new MedusaError(MedusaErrorTypes.INVALID_DATA, `Attribute ${attrVal.attribute_id} doesn't define ${attrVal.value} as a possible_value`)
    }
  }

  const attributeCategoryIds = Array.from(new Set(
    Array.from(attributeMap.values())
      .flatMap(attr => attr.product_categories?.map(cat => cat.id) || [])
  ))

  if (!attributeCategoryIds.length) {
    // If all attributes are global, we don't enforce for product.categories to include the attribute.product_categories, since there are none
    return;
  }

  const invalidProductIds: string[] = []
  for (const product of products) {
    const productCategoryIds = product.categories?.map(cat => cat.id)
    if (!productCategoryIds?.some(prodCatId => attributeCategoryIds.includes(prodCatId))) {
      invalidProductIds.push(product.id)
    }
  }

  if (invalidProductIds.length) {
    throw new MedusaError(MedusaErrorTypes.INVALID_DATA, `The following products aren't linked to any category from the requested attributes:\n${invalidProductIds.join(', ')}`)
  }
};
```

## File: src/workflows/attribute/steps/create-attribute-possible-values.ts
```typescript
import { StepResponse, createStep } from "@medusajs/framework/workflows-sdk"

import { ATTRIBUTE_MODULE } from "../../../modules/attribute"
import AttributeModuleService from "../../../modules/attribute/service"
import { CreateAttributeValueDTO } from "../../../types/attribute"

export const createAttributePossibleValuesStepId = 'create-attribute-possible-values'

export type CreateAttributePossibleValuesStepInput = CreateAttributeValueDTO[]

export const createAttributePossibleValuesStep = createStep(
    createAttributePossibleValuesStepId,
    async (data: CreateAttributePossibleValuesStepInput, { container }) => {
        const service = container.resolve<AttributeModuleService>(ATTRIBUTE_MODULE)

        const values = await service.createAttributePossibleValues(data)

        return new StepResponse(values, values.map(val => val.id))
    },
    async (ids, { container }) => {
        if (!ids?.length) {
            return
        }

        const service = container.resolve<AttributeModuleService>(ATTRIBUTE_MODULE)

        await service.deleteAttributeValues(ids)
    }
)
```

## File: src/workflows/attribute/steps/create-attributes.ts
```typescript
import { createStep, StepResponse } from "@medusajs/framework/workflows-sdk"
import { CreateAttributeStepInput } from "../../../modules/attribute/types/attribute/common"
import AttributeModuleService from "../../../modules/attribute/service"
import { ATTRIBUTE_MODULE } from "../../../modules/attribute"
import { kebabCase } from "@medusajs/framework/utils"

export const createAttributesStepId = 'create-attributes'

export const createAttributesStep = createStep(
    createAttributesStepId,
    async (data: CreateAttributeStepInput, { container }) => {
        const service = container.resolve<AttributeModuleService>(ATTRIBUTE_MODULE)
        const validated = data.map(attribute => {
            let result = { ...attribute }
            if (!attribute.handle) {
                result.handle = kebabCase(attribute.name)
            }
            return result
        })
        //@ts-expect-error
        const created = await service.createAttributes(validated) as any[]
        return new StepResponse(created, created.map(attribute => attribute.id))
    },
    async (createdIds: string[] | undefined, { container }) => {
        if(!createdIds?.length) {
            return
        }
        const service = container.resolve<AttributeModuleService>(ATTRIBUTE_MODULE)
        await service.deleteAttributes(createdIds)
    }
)
```

## File: src/workflows/attribute/steps/delete-attribute.ts
```typescript
// src/workflows/attribute/steps/delete-attribute.ts
import { StepResponse, createStep } from "@medusajs/framework/workflows-sdk"
import { ContainerRegistrationKeys, Modules } from "@medusajs/framework/utils"

import { ATTRIBUTE_MODULE } from "../../../modules/attribute"
import AttributeModuleService from "../../../modules/attribute/service"
import attributeProductCategory from "../../../links/attribute-product-category"
import attributeValueProduct from "../../../links/attribute-value-product"

export const deleteAttributeStepId = 'delete-attribute'

interface CategoryLink {
    attribute_id: string
    product_category_id: string
}

interface ValueLink {
    attribute_value_id: string
    product_id: string
}

export const deleteAttributeStep = createStep(
    deleteAttributeStepId,
    async (ids: string[], { container }) => {
        const attributeModuleService = container.resolve<AttributeModuleService>(ATTRIBUTE_MODULE)
        const query = container.resolve(ContainerRegistrationKeys.QUERY)
        const remoteLink = container.resolve(ContainerRegistrationKeys.REMOTE_LINK)

        // Store the attributes before deletion for potential rollback
        const attributesToDelete = await attributeModuleService.listAttributes({
            id: ids
        })

        // First, get all attribute values for these attributes
        const attributeValues = await attributeModuleService.listAttributeValues({
            attribute_id: ids
        })

        const attributeValueIds = attributeValues.map(av => av.id)

        // Query category links directly by attribute_id
        const { data: categoryLinks } = await query.graph({
            entity: attributeProductCategory.entryPoint,
            fields: ["attribute_id", "product_category_id"],
            filters: {
                attribute_id: ids
            }
        }) as { data: CategoryLink[] }

        // Query attribute value links by attribute_value_id (not nested)
        let valueLinks: ValueLink[] = []
        if (attributeValueIds.length > 0) {
            const { data: valueLinkData } = await query.graph({
                entity: attributeValueProduct.entryPoint,
                fields: ["attribute_value_id", "product_id"],
                filters: {
                    attribute_value_id: attributeValueIds
                }
            }) as { data: ValueLink[] }
            valueLinks = valueLinkData
        }

        // Delete all links first
        if (categoryLinks.length > 0) {
            await remoteLink.dismiss(
                categoryLinks.map(link => ({
                    [ATTRIBUTE_MODULE]: { attribute_id: link.attribute_id },
                    [Modules.PRODUCT]: { product_category_id: link.product_category_id }
                }))
            )
        }

        if (valueLinks.length > 0) {
            await remoteLink.dismiss(
                valueLinks.map(link => ({
                    [ATTRIBUTE_MODULE]: { attribute_value_id: link.attribute_value_id },
                    [Modules.PRODUCT]: { product_id: link.product_id }
                }))
            )
        }

        // Soft delete the attributes (this will cascade to attribute values)
        await attributeModuleService.softDeleteAttributes(ids)

        return new StepResponse(
            { deletedIds: ids, count: ids.length },
            {
                attributesToDelete,
                deletedIds: ids,
                categoryLinks,
                valueLinks,
                attributeValueIds
            }
        )
    },
    async (rollbackData, { container }) => {
        if (!rollbackData?.deletedIds?.length) {
            return
        }

        const attributeModuleService = container.resolve<AttributeModuleService>(ATTRIBUTE_MODULE)
        const remoteLink = container.resolve(ContainerRegistrationKeys.REMOTE_LINK)

        // Restore the soft-deleted attributes
        await attributeModuleService.restoreAttributes(rollbackData.deletedIds)

        // Restore category links
        if (rollbackData.categoryLinks?.length > 0) {
            await remoteLink.create(
                rollbackData.categoryLinks.map((link: CategoryLink) => ({
                    [ATTRIBUTE_MODULE]: { attribute_id: link.attribute_id },
                    [Modules.PRODUCT]: { product_category_id: link.product_category_id }
                }))
            )
        }

        // Restore value links
        if (rollbackData.valueLinks?.length > 0) {
            await remoteLink.create(
                rollbackData.valueLinks.map((link: ValueLink) => ({
                    [ATTRIBUTE_MODULE]: { attribute_value_id: link.attribute_value_id },
                    [Modules.PRODUCT]: { product_id: link.product_id }
                }))
            )
        }
    }
)
```

## File: src/workflows/attribute/steps/index.ts
```typescript
export * from './create-attributes'
export * from './update-attributes'
export * from './create-attribute-possible-values'
export * from './delete-attribute'
```

## File: src/workflows/attribute/steps/update-attributes.ts
```typescript
// src/workflows/attribute/steps/update-attributes.ts
import { StepResponse, WorkflowData, createStep } from "@medusajs/framework/workflows-sdk"

import { ATTRIBUTE_MODULE } from "../../../modules/attribute"
import AttributeModuleService from "../../../modules/attribute/service"
import { UpdateAttributeDTO } from "../../../types/attribute"

const updateAttributesStepId = 'update-attributes'

// Create a type that excludes product_category_ids since it's handled via links
type AttributeUpdateData = Omit<UpdateAttributeDTO, 'product_category_ids'>

export const updateAttributesStep = createStep(
    updateAttributesStepId,
    async (data: WorkflowData<AttributeUpdateData[]>, { container }) => {
        const service = container.resolve<AttributeModuleService>(ATTRIBUTE_MODULE)

        const prevData = await service.listAttributes({
            id: data.map(attribute => attribute.id)
        })

        // Normalize the data for the service method
        const normalized = data.map(attr => {
            const { possible_values: values, ...attribute } = attr;
            const valuesWithAttribute = values?.map(val => ({ ...val, attribute_id: attribute.id }))
            return {
                ...attr,
                possible_values: valuesWithAttribute
            }
        })

        // Update attributes using the service method
        await service.updateAttributeWithUpsertOrReplacePossibleValues(normalized)

        return new StepResponse(data, prevData)
    },
    async (prevData, { container }) => {
        if (!prevData?.length) {
            return
        }

        const service = container.resolve<AttributeModuleService>(ATTRIBUTE_MODULE)

        // Convert back to the format expected by the service
        const rollbackData = prevData.map(attr => {
            const { possible_values, ...attributeData } = attr;
            const valuesWithAttribute = possible_values?.map(val => ({
                ...val,
                attribute_id: attr.id
            }))
            return {
                ...attributeData,
                possible_values: valuesWithAttribute
            }
        }) as Omit<UpdateAttributeDTO, 'product_category_ids'>[]

        await service.updateAttributeWithUpsertOrReplacePossibleValues(rollbackData)
    }
)
```

## File: src/workflows/attribute/workflows/create-attribute-possible-values.ts
```typescript
import { WorkflowResponse, createWorkflow } from "@medusajs/framework/workflows-sdk"

import { CreateAttributeValueDTO } from "../../../types/attribute"
import { createAttributePossibleValuesStep } from "../steps/create-attribute-possible-values"

const createAttributePossibleValuesWorkflowId = 'create-attribute-possible-values'

export type CreateAttributePossibleValuesWorkflowInput = CreateAttributeValueDTO[]

export const createAttributePossibleValuesWorkflow = createWorkflow(
    createAttributePossibleValuesWorkflowId,
    (input: CreateAttributePossibleValuesWorkflowInput) => {
        const createdValues = createAttributePossibleValuesStep(input)

        return new WorkflowResponse(createdValues)
    }
)
```

## File: src/workflows/attribute/workflows/create-attributes.ts
```typescript
import { createWorkflow, transform, when, WorkflowData, WorkflowResponse } from "@medusajs/framework/workflows-sdk";
import { CreateAttributesWorkflowInput } from "../../../modules/attribute/types/attribute/common";
import { createAttributesStep } from "../steps/create-attributes";
import { ATTRIBUTE_MODULE } from "../../../modules/attribute";
import { Modules } from "@medusajs/framework/utils";
import { LinkDefinition } from "@medusajs/framework/types";
import { createRemoteLinkStep, emitEventStep } from "@medusajs/medusa/core-flows";
import { AttributeWorkflowsEvents } from "../../../modules/attribute/events";

export const createAttributesWorkflowId = 'create-attributes'

export const createAttributesWorkflow = createWorkflow(
    createAttributesWorkflowId,
    (input: WorkflowData<CreateAttributesWorkflowInput>) => {
        const attributesWithoutExternalRelations = transform(input, ({ attributes }) => {
            return attributes.map(attribute => {
                const { product_category_ids, ...result } = attribute
                return result 
            })
        })

        const createdAttributes = createAttributesStep(attributesWithoutExternalRelations)

        const productCategoryLinks: LinkDefinition[] = transform({ input, createdAttributes }, ({ input, createdAttributes }) => {
            return createdAttributes.map((attribute, idx) => {
                const inputAttribute = input.attributes[idx]
                return inputAttribute.product_category_ids?.map(productCategoryId => ({
                    [ATTRIBUTE_MODULE]: {
                        attribute_id: attribute.id
                    },
                    [Modules.PRODUCT]: {
                        product_category_id: productCategoryId
                    }
                })) || []
            }).flat()
        })

        when({ productCategoryLinks }, ({ productCategoryLinks }) => {
            return productCategoryLinks.length > 0
        }).then(() => {
            createRemoteLinkStep(productCategoryLinks)
        })


        const attributeEventData = transform({ createdAttributes }, ({ createdAttributes }) => {
            return createdAttributes.map(attribute => attribute.id)
        }) as string[]

        emitEventStep({
            eventName: AttributeWorkflowsEvents.CREATED,
            data: attributeEventData
        })

        return new WorkflowResponse(createdAttributes)
    } 
)
```

## File: src/workflows/attribute/workflows/delete-attribute.ts
```typescript
import {
  createWorkflow,
  WorkflowResponse
} from "@medusajs/framework/workflows-sdk";
import { deleteAttributeStep } from "../steps/delete-attribute";
import { emitEventStep } from "@medusajs/medusa/core-flows";

const deleteAttributeWorkflowId = "delete-attribute";

export type DeleteAttributeWorkflowInput = string[]

export const deleteAttributeWorkflow = createWorkflow(
  deleteAttributeWorkflowId,
  (input: DeleteAttributeWorkflowInput) => {
    const deletedAttributes = deleteAttributeStep(input);

    // Emit deletion event
    emitEventStep({
      eventName: "attribute.deleted",
      data: { deletedIds: input, count: input.length }
    });

    return new WorkflowResponse(deletedAttributes);
  }
);
```

## File: src/workflows/attribute/workflows/index.ts
```typescript
export * from './create-attributes'
export * from './update-attributes'
export * from './create-attribute-possible-values'
export * from './delete-attribute'
```

## File: src/workflows/attribute/workflows/update-attributes.ts
```typescript
// src/workflows/attribute/workflows/update-attributes.ts
import {
  createWorkflow,
  parallelize,
  transform,
  when,
  WorkflowResponse,
} from "@medusajs/framework/workflows-sdk";
import { UpdateAttributeDTO } from "../../../modules/attribute/types/attribute/common";
import { updateAttributesStep } from "../steps";
import { LinkDefinition } from "@medusajs/framework/types";
import { ATTRIBUTE_MODULE } from "../../../modules/attribute";
import { Modules } from "@medusajs/framework/utils";
import { createRemoteLinkStep, dismissRemoteLinkStep, emitEventStep, useQueryGraphStep } from "@medusajs/medusa/core-flows";
import attributeProductCategory from "../../../links/attribute-product-category";
import { AttributeWorkflowsEvents } from "../../../modules/attribute/events";

const updateAttributesWorkflowId = "update-attributes";

export type UpdateAttributesWorkflowInput = {
  attributes: UpdateAttributeDTO[];
};

export const updateAttributesWorkflow = createWorkflow(
  updateAttributesWorkflowId,
  (input: UpdateAttributesWorkflowInput) => {
    // Remove product_category_ids from the attribute update data
    // since it's not a direct field on the attribute table
    const attributesWithoutCategoryIds = transform({ input }, ({ input: { attributes } }) => {
      return attributes.map((attribute) => {
        const { product_category_ids, ...attributeData } = attribute;
        return attributeData;
      });
    });

    // Update the attributes (without category relationships)
    const updatedAttributes = updateAttributesStep(attributesWithoutCategoryIds);

    // Get attributes that have category updates (including empty arrays to clear categories)
    const attributesWithCategoryUpdates = transform({ input }, ({ input: { attributes } }) => {
      return attributes.filter(attr => attr.product_category_ids !== undefined);
    });

    const attributeIdsWithCategoryUpdates = transform({ attributesWithCategoryUpdates }, ({ attributesWithCategoryUpdates }) => {
      return attributesWithCategoryUpdates.map(attr => attr.id);
    });

    // Get current category links for attributes that have category updates
    const currentCategoryLinksResult = useQueryGraphStep({
      entity: attributeProductCategory.entryPoint,
      fields: ["attribute_id", "product_category_id"],
      filters: {
        attribute_id: attributeIdsWithCategoryUpdates,
      },
    });

    const currentCategoryLinks = transform({ currentCategoryLinksResult }, ({ currentCategoryLinksResult }) => {
      return currentCategoryLinksResult.data;
    });

    // Prepare links to delete (all current links for attributes being updated)
    const linksToDelete = transform({ currentCategoryLinks }, ({ currentCategoryLinks }) => {
      if (!currentCategoryLinks.length) {
        return [];
      }

      return currentCategoryLinks.map(({ attribute_id, product_category_id }) => ({
        [ATTRIBUTE_MODULE]: {
          attribute_id
        },
        [Modules.PRODUCT]: {
          product_category_id
        }
      }));
    });

    // Prepare new links to create (only for non-empty category arrays)
    const linksToCreate: LinkDefinition[] = transform(
      { attributesWithCategoryUpdates },
      ({ attributesWithCategoryUpdates }) => {
        return attributesWithCategoryUpdates
          .filter((attribute) => attribute.product_category_ids && attribute.product_category_ids.length > 0)
          .flatMap((attribute) =>
            attribute.product_category_ids!.map((categoryId) => ({
              [ATTRIBUTE_MODULE]: {
                attribute_id: attribute.id,
              },
              [Modules.PRODUCT]: {
                product_category_id: categoryId,
              },
            }))
          );
      }
    );

    const updatedAttributesEventData = transform({ updatedAttributes }, ({ updatedAttributes }) =>
      updatedAttributes.map(attr => attr.id)
    );

    // Handle link operations conditionally
    when({ linksToDelete }, ({ linksToDelete }) => {
      return linksToDelete.length > 0;
    }).then(() => {
      dismissRemoteLinkStep(linksToDelete);
    });

    when({ linksToCreate }, ({ linksToCreate }) => {
      return linksToCreate.length > 0;
    }).then(() => {
      createRemoteLinkStep(linksToCreate);
    });

    // Emit event
    emitEventStep({
      eventName: AttributeWorkflowsEvents.UPDATED,
      data: updatedAttributesEventData
    });

    return new WorkflowResponse(updatedAttributes);
  }
);
```

## File: src/workflows/attribute/index.ts
```typescript
export * from './workflows'
export * from './steps'
```

## File: src/workflows/attribute-set/steps/create-attribute-set.ts
```typescript
import { StepResponse, createStep } from "@medusajs/framework/workflows-sdk"

import { ATTRIBUTE_MODULE } from "../../../modules/attribute"
import AttributeModuleService from "../../../modules/attribute/service"
import { CreateAttributeSetDTO } from "../../../modules/attribute/types"
import { kebabCase } from "@medusajs/framework/utils"

export const createAttributeSetStepId = 'create-attribute-set'

export const createAttributeSetStep = createStep(
    createAttributeSetStepId,
    async (input: CreateAttributeSetDTO | CreateAttributeSetDTO[], { container }) => {
        const attributeModuleService = container.resolve<AttributeModuleService>(ATTRIBUTE_MODULE)

        const normalizedInput = Array.isArray(input) ? input : [input]

        const toCreate = normalizedInput.map(attributeSet => ({
            ...attributeSet,
            handle: attributeSet.handle ?? kebabCase(attributeSet.name)
        }))

        const created = await attributeModuleService.createAttributeSets(toCreate)

        return new StepResponse(created, created.map(set => set.id))
    },
    async (ids: string[] | undefined, { container }) => {
        if (!ids?.length) {
            return
        }

        const attributeModuleService = container.resolve<AttributeModuleService>(ATTRIBUTE_MODULE)
        await attributeModuleService.deleteAttributeSets(ids)
    }
)
```

## File: src/workflows/attribute-set/steps/index.ts
```typescript
export * from './create-attribute-set'
```

## File: src/workflows/attribute-set/workflows/create-attribute-set.ts
```typescript
import { WorkflowResponse, createWorkflow, transform } from "@medusajs/framework/workflows-sdk"

import { CreateAttributeSetDTO } from "../../../modules/attribute/types"
import { createAttributeSetStep } from "../steps"

export const createAttributeSetWorkflowId = 'create-attribute-set'

export type CreateAttributeSetWorkflowInput = CreateAttributeSetDTO[]

export const createAttributeSetWorkflow = createWorkflow(
    createAttributeSetWorkflowId,
    (input: CreateAttributeSetWorkflowInput) => {
        const created = createAttributeSetStep(input)

        return new WorkflowResponse(created)
    }
)
```

## File: src/workflows/attribute-value/steps/create-attribute-value.ts
```typescript
import { StepResponse, createStep } from "@medusajs/framework/workflows-sdk"

import { ATTRIBUTE_MODULE } from "../../../modules/attribute";
import AttributeModuleService from "../../../modules/attribute/service";
import { CreateProductAttributeValueDTO } from "../../../modules/attribute/types"

export const createAttributeValueStepId = 'create-attribute-value'

export const createAttributeValueStep = createStep(
    createAttributeValueStepId,
    async (input: Omit<CreateProductAttributeValueDTO, 'product_id'>, { container }) => {
        const attributeModuleService = container.resolve<AttributeModuleService>(ATTRIBUTE_MODULE)
        
        const created = await attributeModuleService.createAttributeValues(input)

        return new StepResponse(created, created.id)
    },
    async (id: string | undefined, { container }) => {
        if (!id) {
            return;
        }
        
        const attributeModuleService = container.resolve<AttributeModuleService>(ATTRIBUTE_MODULE)
        await attributeModuleService.deleteAttributeValues(id)
    }
)
```

## File: src/workflows/attribute-value/steps/delete-attribute-value.ts
```typescript
import { StepResponse, createStep } from "@medusajs/framework/workflows-sdk"

import { ATTRIBUTE_MODULE } from "../../../modules/attribute"
import AttributeModuleService from "../../../modules/attribute/service"

export const deleteAttributeValueStepId = 'delete-attribute-value'

export const deleteAttributeValueStep = createStep(
    deleteAttributeValueStepId,
    async (ids: string[], { container }) => {
        const attributeModuleService = container.resolve<AttributeModuleService>(ATTRIBUTE_MODULE)

        await attributeModuleService.softDeleteAttributeValues(ids)

        return new StepResponse(ids, ids)
    },
    async (ids: string[] | undefined, { container }) => {
        if (!ids?.length) {
            return
        }
        
        const attributeModuleService = container.resolve<AttributeModuleService>(ATTRIBUTE_MODULE)

        await attributeModuleService.restoreAttributeValues(ids)
    },
)
```

## File: src/workflows/attribute-value/steps/index.ts
```typescript
export * from './create-attribute-value'
export * from './validate-attribute-value'
export * from './delete-attribute-value'
```

## File: src/workflows/attribute-value/steps/validate-attribute-value.ts
```typescript
import {
  ContainerRegistrationKeys,
  MedusaError,
  MedusaErrorTypes,
} from "@medusajs/framework/utils";
import { StepResponse, createStep } from "@medusajs/framework/workflows-sdk";

import { CreateProductAttributeValueDTO } from "../../../modules/attribute/types";
import attributeValueProduct from "../../../links/attribute-value-product";
import { ATTRIBUTE_MODULE } from "../../../modules/attribute";
import AttributeModuleService from "../../../modules/attribute/service";

export const validateAttributeValueStepId = "validate-attribute-value";

export const validateAttributeValueStep = createStep(
  validateAttributeValueStepId,
  async (input: CreateProductAttributeValueDTO, { container }) => {
    const query = container.resolve(ContainerRegistrationKeys.QUERY);
    const attributeModuleService = container.resolve<AttributeModuleService>(ATTRIBUTE_MODULE);

    // Validate attribute exists and get its constraints
    const {
      data: [attribute],
    } = await query.graph({
      entity: "attribute",
      fields: ["id", "name", "product_categories.id", "possible_values.value"],
      filters: {
        id: input.attribute_id,
      },
    });

    if (!attribute) {
      throw new MedusaError(
        MedusaErrorTypes.NOT_FOUND,
        `Attribute ${input.attribute_id} not found`
      );
    }

    // Check if value is allowed (if possible values are defined)
    const allowedValues = attribute.possible_values?.map(
      (posVal) => posVal.value
    );

    if (allowedValues?.length && !allowedValues.includes(input.value)) {
      throw new MedusaError(
        MedusaErrorTypes.INVALID_DATA,
        `Attribute ${attribute.name} doesn't define '${input.value}' as a possible value. Allowed values: ${allowedValues.join(', ')}`
      );
    }

    const attributeCategoryIds = attribute.product_categories?.map(
      (cat) => cat.id
    ) || [];

    // Validate product-category constraints (if attribute has category restrictions)
    if (attributeCategoryIds.length > 0) {
      const {
        data: [product],
      } = await query.graph({
        entity: "product",
        fields: ["id", "categories.id"],
        filters: {
          id: input.product_id,
        },
      });

      if (!product) {
        throw new MedusaError(
          MedusaErrorTypes.NOT_FOUND,
          `Product ${input.product_id} not found`
        );
      }

      const productCategoryIds = product.categories?.map((cat) => cat.id) || [];

      if (
        !productCategoryIds.some((prodCatId) =>
          attributeCategoryIds.includes(prodCatId)
        )
      ) {
        throw new MedusaError(
          MedusaErrorTypes.INVALID_DATA,
          `Product ${input.product_id} must be in one of the categories that this attribute is restricted to.`
        );
      }
    }

    // Simplified duplicate check - get all links for this product first
    const { data: productLinks } = await query.graph({
      entity: attributeValueProduct.entryPoint,
      fields: ["attribute_value_id"],
      filters: {
        product_id: input.product_id,
      },
    });

    // If product has any attribute value links, check them
    if (productLinks.length > 0) {
      const linkedAttributeValueIds = productLinks.map(link => link.attribute_value_id);

      // Get the actual attribute values to check for duplicates
      const linkedAttributeValues = await attributeModuleService.listAttributeValues({
        id: linkedAttributeValueIds
      });

      // Check if any existing values match this attribute + value combo
      const duplicateValue = linkedAttributeValues.find(av =>
        av.attribute_id === input.attribute_id && av.value === input.value
      );

      if (duplicateValue) {
        throw new MedusaError(
          MedusaErrorTypes.DUPLICATE_ERROR,
          `Attribute value '${input.value}' for attribute '${attribute.name}' already exists for this product`
        );
      }
    }

    return new StepResponse();
  }
);
```

## File: src/workflows/attribute-value/workflow/create-attribute-value.ts
```typescript
import { WorkflowResponse, createWorkflow, transform } from "@medusajs/framework/workflows-sdk"
import { createAttributeValueStep, validateAttributeValueStep } from "../steps"

import { ATTRIBUTE_MODULE } from "../../../modules/attribute"
import { CreateProductAttributeValueDTO } from "../../../modules/attribute/types"
import { Modules } from "@medusajs/framework/utils"
import { createRemoteLinkStep, } from "@medusajs/medusa/core-flows"

export const createAttributeValueWorkflowId = 'create-attribute-value'

export const createAttributeValueWorkflow = createWorkflow(
    createAttributeValueWorkflowId,
    (input: CreateProductAttributeValueDTO) => {
        const attributeValueWithoutExternalRelations = transform({ input }, ({ input }) => {
            const { product_id, ...attributeValue } = input
            return attributeValue
        })
 
        validateAttributeValueStep(input)
        
        const attributeValue = createAttributeValueStep(attributeValueWithoutExternalRelations)

        const link = transform({ input, attributeValue }, ({ input, attributeValue }) => ([{
            [ATTRIBUTE_MODULE]: {
                attribute_value_id: attributeValue.id,
            },
            [Modules.PRODUCT]: {
                product_id: input.product_id
            }
        }]))
        
        createRemoteLinkStep(link)
        
        return new WorkflowResponse(attributeValue)
    }
)
```

## File: src/workflows/attribute-value/workflow/delete-attribute-value.ts
```typescript
import { WorkflowResponse, createWorkflow, transform } from "@medusajs/framework/workflows-sdk"
import { dismissRemoteLinkStep, useQueryGraphStep } from "@medusajs/medusa/core-flows"

import { ATTRIBUTE_MODULE } from "../../../modules/attribute"
import { Modules } from "@medusajs/framework/utils"
import attributeValueProduct from "../../../links/attribute-value-product"
import { deleteAttributeValueStep } from "../steps"

export const deleteAttributeValueWorkflowId = 'delete-attribute-value'

export type DeleteAttributeValueWorkflowInput = string | string[]

export const deleteAttributeValueWorkflow = createWorkflow(
    deleteAttributeValueWorkflowId,
    (input: DeleteAttributeValueWorkflowInput) => {
        const normalizedInput = transform({ input }, ({ input }) =>
            Array.isArray(input) ? input : [input]
        )

        // Query current product links before deletion using the link entity
        const attributeValueProductQuery = useQueryGraphStep({
            entity: attributeValueProduct.entryPoint,
            fields: ["attribute_value_id", "product_id"],
            filters: {
                attribute_value_id: normalizedInput
            }
        })

        // Delete the attribute values
        const deleted = deleteAttributeValueStep(normalizedInput)

        // Prepare links to dismiss using the actual link data
        const links = transform({ attributeValueProductQuery }, ({ attributeValueProductQuery }) => {
            const { data } = attributeValueProductQuery;
            return data.map(link => ({
                [ATTRIBUTE_MODULE]: {
                    attribute_value_id: link.attribute_value_id,
                },
                [Modules.PRODUCT]: {
                    product_id: link.product_id
                }
            }))
        })

        // Dismiss the links
        dismissRemoteLinkStep(links)

        return new WorkflowResponse(deleted)
    }
)
```

## File: src/workflows/attribute-value/workflow/index.ts
```typescript
export * from './create-attribute-value'
export * from './delete-attribute-value'
```

## File: src/workflows/index.ts
```typescript
export * from './attribute'
```

## File: src/workflows/README.md
```markdown
# Custom Workflows

A workflow is a series of queries and actions that complete a task.

The workflow is created in a TypeScript or JavaScript file under the `src/workflows` directory.

For example:

```ts
import {
  createStep,
  createWorkflow,
  WorkflowResponse,
  StepResponse,
} from "@medusajs/framework/workflows-sdk"

const step1 = createStep("step-1", async () => {
  return new StepResponse(`Hello from step one!`)
})

type WorkflowInput = {
  name: string
}

const step2 = createStep(
  "step-2",
  async ({ name }: WorkflowInput) => {
    return new StepResponse(`Hello ${name} from step two!`)
  }
)

type WorkflowOutput = {
  message1: string
  message2: string
}

const helloWorldWorkflow = createWorkflow(
  "hello-world",
  (input: WorkflowInput) => {
    const greeting1 = step1()
    const greeting2 = step2(input)
    
    return new WorkflowResponse({
      message1: greeting1,
      message2: greeting2
    })
  }
)

export default helloWorldWorkflow
```

## Execute Workflow

You can execute the workflow from other resources, such as API routes, scheduled jobs, or subscribers.

For example, to execute the workflow in an API route:

```ts
import type {
  MedusaRequest,
  MedusaResponse,
} from "@medusajs/framework"
import myWorkflow from "../../../workflows/hello-world"

export async function GET(
  req: MedusaRequest,
  res: MedusaResponse
) {
  const { result } = await myWorkflow(req.scope)
    .run({
      input: {
        name: req.query.name as string,
      },
    })

  res.send(result)
}
```
```

## File: .gitignore
```
/dist
.env
.DS_Store
/uploads
/node_modules
yarn-error.log

.idea

coverage

!src/**

./tsconfig.tsbuildinfo
medusa-db.sql
build
.cache

.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/sdks
!.yarn/versions

.medusa
```

## File: package.json
```json
{
  "name": "@aiclipse/medusa-product-attributes",
  "version": "2.1.3",
  "description": "A plugin for adding attributes support to MedusaJS products",
  "author": "Nishit Gupta (https://github.com/nishit-g)",
  "license": "MIT",
  "files": [
    ".medusa/server"
  ],
  "exports": {
    "./package.json": "./package.json",
    "./workflows": "./.medusa/server/src/workflows/index.js",
    "./.medusa/server/src/modules/*": "./.medusa/server/src/modules/*/index.js",
    "./providers/*": "./.medusa/server/src/providers/*/index.js",
    "./admin": {
      "import": "./.medusa/server/src/admin/index.mjs",
      "require": "./.medusa/server/src/admin/index.js",
      "default": "./.medusa/server/src/admin/index.js"
    },
    "./*": "./.medusa/server/src/*.js"
  },
  "keywords": [
    "medusa",
    "plugin",
    "medusa-plugin-other",
    "medusa-plugin",
    "medusa-v2",
    "product-attributes",
    "medusa-product"
  ],
  "scripts": {
    "build": "medusa plugin:build",
    "dev": "medusa plugin:develop",
    "prepublishOnly": "medusa plugin:build"
  },
  "devDependencies": {
    "@medusajs/admin-sdk": "2.7.1",
    "@medusajs/cli": "2.7.1",
    "@medusajs/framework": "2.7.1",
    "@medusajs/medusa": "2.7.1",
    "@medusajs/test-utils": "2.7.1",
    "@medusajs/ui-preset": "2.7.1",
    "@medusajs/ui": "4.0.4",
    "@medusajs/icons": "2.7.1",
    "@mikro-orm/cli": "6.4.3",
    "@mikro-orm/core": "6.4.3",
    "@mikro-orm/knex": "6.4.3",
    "@mikro-orm/migrations": "6.4.3",
    "@mikro-orm/postgresql": "6.4.3",
    "@swc/core": "1.5.7",
    "@types/node": "^20.0.0",
    "@types/react": "^18.3.2",
    "radix-ui": "1.1.2",
    "@types/react-dom": "^18.2.25",
    "awilix": "^8.0.1",
    "pg": "^8.13.0",
    "prop-types": "^15.8.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.6.2",
    "vite": "^5.2.11",
    "yalc": "^1.0.0-pre.53"
  },
  "peerDependencies": {
    "@medusajs/admin-sdk": "2.7.1",
    "@medusajs/cli": "2.7.1",
    "@medusajs/framework": "2.7.1",
    "@medusajs/test-utils": "2.7.1",
    "@medusajs/medusa": "2.7.1",
    "@medusajs/ui": "4.0.9",
    "@medusajs/icons": "2.7.1",
    "@mikro-orm/cli": "6.4.3",
    "@mikro-orm/core": "6.4.3",
    "@mikro-orm/knex": "6.4.3",
    "@mikro-orm/core": "6.4.3",
    "@mikro-orm/knex": "6.4.3",
    "@mikro-orm/migrations": "6.4.3",
    "@mikro-orm/postgresql": "6.4.3",
    "awilix": "^8.0.1",
    "pg": "^8.13.0"
  },
  "engines": {
    "node": ">=20"
  },
  "packageManager": "yarn@1.22.22+sha512.a6b2f7906b721bba3d67d4aff083df04dad64c399707841b7acf00f6b133b7ac24255f2652fa22ae3534329dc6180534e98d17432037ff6fd140556e2bb3137e"
}
```

## File: repomix.config.json
```json
{
  "output": {
    "filePath": "product-attributes-plugin.md",
    "style": "markdown",
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": ["src/modules/attribute/migrations/*.json", "src/admin/components/category-combobox.tsx", "CHANGELOG.md", "README.md", "src/modules/attribute/migrations/*.ts", "src/api/*.md"]
  },
  "security": {
    "enableSecurityCheck": true
  }
}
```

## File: tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2021",
    "esModuleInterop": true,
    "module": "Node16",
    "moduleResolution": "Node16",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "skipLibCheck": true,
    "skipDefaultLibCheck": true,
    "declaration": false,
    "sourceMap": false,
    "inlineSourceMap": true,
    "outDir": "./.medusa/server",
    "rootDir": "./",
    "jsx": "react-jsx",
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "checkJs": false,
    "strictNullChecks": true
  },
  "ts-node": {
    "swc": true
  },
  "include": [
    "**/*",
    ".medusa/types/*"
  ],
  "exclude": [
    "node_modules",
    ".medusa/server",
    ".medusa/admin",
    "src/admin",
    ".cache"
  ]
}
```
